(()=>{var e={55:(e,t,n)=>{const{Socket:i}=n(808);const{Duplex:r}=n(781);const{isParsedKey:s,parseKey:o}=n(887);const{makeBufferParser:f,readUInt32BE:h,writeUInt32BE:l}=n(223);function once(e){let t=false;return(...n)=>{if(t)return;t=true;e(...n)}}function concat(e,t){const n=Buffer.allocUnsafe(e.length+t.length);e.copy(n,0);t.copy(n,e.length);return n}function noop(){}const u=Buffer.alloc(0);const A=f();class BaseAgent{getIdentities(e){e(new Error("Missing getIdentities() implementation"))}sign(e,t,n,i){if(typeof n==="function")i=n;i(new Error("Missing sign() implementation"))}}class OpenSSHAgent extends BaseAgent{constructor(e){super();this.socketPath=e}getStream(e){e=once(e);const t=new i;t.on("connect",(()=>{e(null,t)}));t.on("close",onFail).on("end",onFail).on("error",onFail);t.connect(this.socketPath);function onFail(){try{t.destroy()}catch{}e(new Error("Failed to connect to agent"))}}getIdentities(e){e=once(e);this.getStream(((t,n)=>{function onFail(t){if(n){try{n.destroy()}catch{}}if(!t)t=new Error("Failed to retrieve identities from agent");e(t)}if(t)return onFail(t);const i=new g(true);i.on("error",onFail);i.pipe(n).pipe(i);n.on("close",onFail).on("end",onFail).on("error",onFail);i.getIdentities(((t,i)=>{if(t)return onFail(t);try{n.destroy()}catch{}e(null,i)}))}))}sign(e,t,n,i){if(typeof n==="function"){i=n;n=undefined}else if(typeof n!=="object"||n===null){n=undefined}i=once(i);this.getStream(((r,s)=>{function onFail(e){if(s){try{s.destroy()}catch{}}if(!e)e=new Error("Failed to sign data with agent");i(e)}if(r)return onFail(r);const o=new g(true);o.on("error",onFail);o.pipe(s).pipe(o);s.on("close",onFail).on("end",onFail).on("error",onFail);o.sign(e,t,n,((e,t)=>{if(e)return onFail(e);try{s.destroy()}catch{}i(null,t)}))}))}}function createAgent(e){return new OpenSSHAgent(e)}const g=(()=>{const e=11;const t=13;const n=5;const i=12;const f=14;const g=1<<1;const _=1<<2;const p=0;const E=1;function processResponses(e){let t;while(e[m].length){const n=e[m][0][S];if(n===undefined)break;e[m].shift();t=e.push(n)}return t}const b=Symbol("Inbound Request Type");const S=Symbol("Inbound Request Response");const y=Symbol("Inbound Request Context");class AgentInboundRequest{constructor(e,t){this[b]=e;this[S]=undefined;this[y]=t}hasResponded(){return this[S]!==undefined}getType(){return this[b]}getContext(){return this[y]}}function respond(e,t,n){t[S]=n;return processResponses(e)}function cleanup(e){e[C]=null;if(e[w]===p){const t=e[m];if(t&&t.length){e[m]=[];for(const e of t)e.cb(new Error("No reply from server"))}}try{e.end()}catch{}setImmediate((()=>{if(!e[R])e.emit("end");if(!e[k])e.emit("close")}))}function onClose(){this[k]=true}function onEnd(){this[R]=true}const m=Symbol("Requests");const w=Symbol("Agent Protocol Role");const C=Symbol("Agent Protocol Buffer");const B=Symbol("Agent Protocol Current Message Length");const k=Symbol("Agent Protocol Closed");const R=Symbol("Agent Protocol Ended");return class AgentProtocol extends r{constructor(e){super({autoDestroy:true,emitClose:false});this[w]=e?p:E;this[m]=[];this[C]=null;this[B]=-1;this.once("end",onEnd);this.once("close",onClose)}_read(e){}_write(r,s,l){if(this[C]===null)this[C]=r;else this[C]=concat(this[C],r);let u=this[C];let E=u.length;let b=0;while(b<E){if(E<5)break;if(this[B]===-1)this[B]=h(u,b);if(E<4+this[B])break;const r=u[b+=4];++b;if(this[w]===p){if(this[m].length===0)return l(new Error("Received unexpected message from server"));const s=this[m].shift();switch(r){case n:s.cb(new Error("Agent responded with failure"));break;case i:{if(s.type!==e)return l(new Error("Agent responded with wrong message type"));A.init(u,b);const t=A.readUInt32BE();if(t===undefined){A.clear();return l(new Error("Malformed agent response"))}const n=[];for(let e=0;e<t;++e){let e=A.readString();if(e===undefined){A.clear();return l(new Error("Malformed agent response"))}const t=A.readString(true);if(t===undefined){A.clear();return l(new Error("Malformed agent response"))}e=o(e);if(e instanceof Error)continue;e.comment=e.comment||t;n.push(e)}b=A.pos();A.clear();s.cb(null,n);break}case f:{if(s.type!==t)return l(new Error("Agent responded with wrong message type"));A.init(u,b);let e=A.readString();b=A.pos();A.clear();if(e===undefined)return l(new Error("Malformed agent response"));A.init(e,0);A.readString(true);e=A.readString();A.clear();if(e===undefined)return l(new Error("Malformed OpenSSH signature format"));s.cb(null,e);break}default:return l(new Error("Agent responded with unsupported message type"))}}else{switch(r){case e:{const e=new AgentInboundRequest(r);this[m].push(e);this.emit("identities",e);break}case t:{A.init(u,b);let e=A.readString();const t=A.readString();const n=A.readUInt32BE();b=A.pos();A.clear();if(n===undefined){const e=new AgentInboundRequest(r);this[m].push(e);return this.failureReply(e)}e=o(e);if(e instanceof Error){const e=new AgentInboundRequest(r);this[m].push(e);return this.failureReply(e)}const i={hash:undefined};let s;if(e.type==="ssh-rsa"){if(n&g){s="rsa-sha2-256";i.hash="sha256"}else if(n&_){s="rsa-sha2-512";i.hash="sha512"}}if(s===undefined)s=e.type;const f=new AgentInboundRequest(r,s);this[m].push(f);this.emit("sign",f,e,t,i);break}default:{const e=new AgentInboundRequest(r);this[m].push(e);this.failureReply(e)}}}this[B]=-1;if(b===E){this[C]=null;break}else{this[C]=u=u.slice(b);E=u.length;b=0}}l()}_destroy(e,t){cleanup(this);t()}_final(e){cleanup(this);e()}sign(e,n,i,r){if(this[w]!==p)throw new Error("Client-only method called with server role");if(typeof i==="function"){r=i;i=undefined}else if(typeof i!=="object"||i===null){i=undefined}let s=0;e=o(e);if(e instanceof Error)throw new Error("Invalid public key argument");if(e.type==="ssh-rsa"&&i){switch(i.hash){case"sha256":s=g;break;case"sha512":s=_;break}}e=e.getPublicSSH();const f=t;const h=e.length;const u=n.length;let A=0;const E=Buffer.allocUnsafe(4+1+4+h+4+u+4);l(E,E.length-4,A);E[A+=4]=f;l(E,h,++A);e.copy(E,A+=4);l(E,u,A+=h);n.copy(E,A+=4);l(E,s,A+=u);if(typeof r!=="function")r=noop;this[m].push({type:f,cb:r});return this.push(E)}getIdentities(t){if(this[w]!==p)throw new Error("Client-only method called with server role");const n=e;let i=0;const r=Buffer.allocUnsafe(4+1);l(r,r.length-4,i);r[i+=4]=n;if(typeof t!=="function")t=noop;this[m].push({type:n,cb:t});return this.push(r)}failureReply(e){if(this[w]!==E)throw new Error("Server-only method called with client role");if(!(e instanceof AgentInboundRequest))throw new Error("Wrong request argument");if(e.hasResponded())return true;let t=0;const i=Buffer.allocUnsafe(4+1);l(i,i.length-4,t);i[t+=4]=n;return respond(this,e,i)}getIdentitiesReply(t,n){if(this[w]!==E)throw new Error("Server-only method called with client role");if(!(t instanceof AgentInboundRequest))throw new Error("Wrong request argument");if(t.hasResponded())return true;if(t.getType()!==e)throw new Error("Invalid response to request");if(!Array.isArray(n))throw new Error("Keys argument must be an array");let r=4;const f=[];for(let e=0;e<n.length;++e){const t=n[e];if(typeof t!=="object"||t===null)throw new Error(`Invalid key entry: ${t}`);let i;let h;if(s(t)){i=t}else if(s(t.pubKey)){i=t.pubKey}else{if(typeof t.pubKey!=="object"||t.pubKey===null)continue;({pubKey:i,comment:h}=t.pubKey);i=o(i);if(i instanceof Error)continue}h=i.comment||h;i=i.getPublicSSH();r+=4+i.length;if(h&&typeof h==="string")h=Buffer.from(h);else if(!Buffer.isBuffer(h))h=u;r+=4+h.length;f.push({pubKey:i,comment:h})}let h=0;const A=Buffer.allocUnsafe(4+1+r);l(A,A.length-4,h);A[h+=4]=i;l(A,f.length,++h);h+=4;for(let e=0;e<f.length;++e){const{pubKey:t,comment:n}=f[e];l(A,t.length,h);t.copy(A,h+=4);l(A,n.length,h+=t.length);h+=4;if(n.length){n.copy(A,h);h+=n.length}}return respond(this,t,A)}signReply(e,n){if(this[w]!==E)throw new Error("Server-only method called with client role");if(!(e instanceof AgentInboundRequest))throw new Error("Wrong request argument");if(e.hasResponded())return true;if(e.getType()!==t)throw new Error("Invalid response to request");if(!Buffer.isBuffer(n))throw new Error("Signature argument must be a Buffer");if(n.length===0)throw new Error("Signature argument must be non-empty");let i=0;const r=e.getContext();const s=Buffer.byteLength(r);const o=Buffer.allocUnsafe(4+1+4+4+s+4+n.length);l(o,o.length-4,i);o[i+=4]=f;l(o,4+s+4+n.length,++i);l(o,s,i+=4);o.utf8Write(r,i+=4,s);l(o,n.length,i+=s);n.copy(o,i+=4);return respond(this,e,o)}}})();const _=Symbol("Agent");const p=Symbol("Agent Keys");const E=Symbol("Agent Keys Index");const b=Symbol("Agent Init Callbacks");class AgentContext{constructor(e){if(typeof e==="string")e=createAgent(e);else if(!isAgent(e))throw new Error("Invalid agent argument");this[_]=e;this[p]=null;this[E]=-1;this[b]=null}init(e){if(typeof e!=="function")e=noop;if(this[p]===null){if(this[b]===null){this[b]=[e];const doCbs=(...e)=>{process.nextTick((()=>{const t=this[b];this[b]=null;for(const n of t)n(...e)}))};this[_].getIdentities(once(((e,t)=>{if(e)return doCbs(e);if(!Array.isArray(t)){return doCbs(new Error("Agent implementation failed to provide keys"))}const n=[];for(let e of t){e=o(e);if(e instanceof Error){continue}n.push(e)}this[p]=n;this[E]=-1;doCbs()})))}else{this[b].push(e)}}else{process.nextTick(e)}}nextKey(){if(this[p]===null||++this[E]>=this[p].length){return false}return this[p][this[E]]}currentKey(){if(this[p]===null||this[E]>=this[p].length){return null}return this[p][this[E]]}pos(){if(this[p]===null||this[E]>=this[p].length){return-1}return this[E]}reset(){this[E]=-1}sign(...e){this[_].sign(...e)}}function isAgent(e){return e instanceof BaseAgent}e.exports={AgentContext:AgentContext,AgentProtocol:g,BaseAgent:BaseAgent,createAgent:createAgent,isAgent:isAgent,OpenSSHAgent:OpenSSHAgent}},81:e=>{e.exports={newInvalidAsn1Error:function(e){const t=new Error;t.name="InvalidAsn1Error";t.message=e||"";return t}}},959:(e,t,n)=>{const i=n(81);const r=n(574);const s=n(415);const o=n(339);e.exports={Reader:s,Writer:o};for(const t in r){if(r.hasOwnProperty(t))e.exports[t]=r[t]}for(const t in i){if(i.hasOwnProperty(t))e.exports[t]=i[t]}},415:(e,t,n)=>{const r=n(491);const s=n(574);const o=n(81);const f=o.newInvalidAsn1Error;function Reader(e){if(!e||!Buffer.isBuffer(e))throw new TypeError("data must be a node Buffer");this._buf=e;this._size=e.length;this._len=0;this._offset=0}Object.defineProperty(Reader.prototype,"length",{enumerable:true,get:function(){return this._len}});Object.defineProperty(Reader.prototype,"offset",{enumerable:true,get:function(){return this._offset}});Object.defineProperty(Reader.prototype,"remain",{get:function(){return this._size-this._offset}});Object.defineProperty(Reader.prototype,"buffer",{get:function(){return this._buf.slice(this._offset)}});Reader.prototype.readByte=function(e){if(this._size-this._offset<1)return null;const t=this._buf[this._offset]&255;if(!e)this._offset+=1;return t};Reader.prototype.peek=function(){return this.readByte(true)};Reader.prototype.readLength=function(e){if(e===undefined)e=this._offset;if(e>=this._size)return null;let t=this._buf[e++]&255;if(t===null)return null;if((t&128)===128){t&=127;if(t===0)throw f("Indefinite length not supported");if(t>4)throw f("encoding too long");if(this._size-e<t)return null;this._len=0;for(let n=0;n<t;n++)this._len=(this._len<<8)+(this._buf[e++]&255)}else{this._len=t}return e};Reader.prototype.readSequence=function(e){const t=this.peek();if(t===null)return null;if(e!==undefined&&e!==t)throw f("Expected 0x"+e.toString(16)+": got 0x"+t.toString(16));const n=this.readLength(this._offset+1);if(n===null)return null;this._offset=n;return t};Reader.prototype.readInt=function(){return this._readTag(s.Integer)};Reader.prototype.readBoolean=function(){return this._readTag(s.Boolean)!==0};Reader.prototype.readEnumeration=function(){return this._readTag(s.Enumeration)};Reader.prototype.readString=function(e,t){if(!e)e=s.OctetString;const n=this.peek();if(n===null)return null;if(n!==e)throw f("Expected 0x"+e.toString(16)+": got 0x"+n.toString(16));const i=this.readLength(this._offset+1);if(i===null)return null;if(this.length>this._size-i)return null;this._offset=i;if(this.length===0)return t?Buffer.alloc(0):"";const r=this._buf.slice(this._offset,this._offset+this.length);this._offset+=this.length;return t?r:r.toString("utf8")};Reader.prototype.readOID=function(e){if(!e)e=s.OID;const t=this.readString(e,true);if(t===null)return null;const n=[];let i=0;for(let e=0;e<t.length;e++){const r=t[e]&255;i<<=7;i+=r&127;if((r&128)===0){n.push(i);i=0}}i=n.shift();n.unshift(i%40);n.unshift(i/40>>0);return n.join(".")};Reader.prototype._readTag=function(e){r.ok(e!==undefined);const t=this.peek();if(t===null)return null;if(t!==e)throw f("Expected 0x"+e.toString(16)+": got 0x"+t.toString(16));const n=this.readLength(this._offset+1);if(n===null)return null;if(this.length>4)throw f("Integer too long: "+this.length);if(this.length>this._size-n)return null;this._offset=n;const s=this._buf[this._offset];let o=0;for(let e=0;e<this.length;e++){o<<=8;o|=this._buf[this._offset++]&255}if((s&128)===128&&i!==4)o-=1<<i*8;return o>>0};e.exports=Reader},574:e=>{e.exports={EOC:0,Boolean:1,Integer:2,BitString:3,OctetString:4,Null:5,OID:6,ObjectDescriptor:7,External:8,Real:9,Enumeration:10,PDV:11,Utf8String:12,RelativeOID:13,Sequence:16,Set:17,NumericString:18,PrintableString:19,T61String:20,VideotexString:21,IA5String:22,UTCTime:23,GeneralizedTime:24,GraphicString:25,VisibleString:26,GeneralString:28,UniversalString:29,CharacterString:30,BMPString:31,Constructor:32,Context:128}},339:(e,t,n)=>{const i=n(491);const r=n(574);const s=n(81);const o=s.newInvalidAsn1Error;const f={size:1024,growthFactor:8};function merge(e,t){i.ok(e);i.equal(typeof e,"object");i.ok(t);i.equal(typeof t,"object");const n=Object.getOwnPropertyNames(e);n.forEach((function(n){if(t[n])return;const i=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,i)}));return t}function Writer(e){e=merge(f,e||{});this._buf=Buffer.alloc(e.size||1024);this._size=this._buf.length;this._offset=0;this._options=e;this._seq=[]}Object.defineProperty(Writer.prototype,"buffer",{get:function(){if(this._seq.length)throw o(this._seq.length+" unended sequence(s)");return this._buf.slice(0,this._offset)}});Writer.prototype.writeByte=function(e){if(typeof e!=="number")throw new TypeError("argument must be a Number");this._ensure(1);this._buf[this._offset++]=e};Writer.prototype.writeInt=function(e,t){if(typeof e!=="number")throw new TypeError("argument must be a Number");if(typeof t!=="number")t=r.Integer;let n=4;while(((e&4286578688)===0||(e&4286578688)===4286578688>>0)&&n>1){n--;e<<=8}if(n>4)throw o("BER ints cannot be > 0xffffffff");this._ensure(2+n);this._buf[this._offset++]=t;this._buf[this._offset++]=n;while(n-- >0){this._buf[this._offset++]=(e&4278190080)>>>24;e<<=8}};Writer.prototype.writeNull=function(){this.writeByte(r.Null);this.writeByte(0)};Writer.prototype.writeEnumeration=function(e,t){if(typeof e!=="number")throw new TypeError("argument must be a Number");if(typeof t!=="number")t=r.Enumeration;return this.writeInt(e,t)};Writer.prototype.writeBoolean=function(e,t){if(typeof e!=="boolean")throw new TypeError("argument must be a Boolean");if(typeof t!=="number")t=r.Boolean;this._ensure(3);this._buf[this._offset++]=t;this._buf[this._offset++]=1;this._buf[this._offset++]=e?255:0};Writer.prototype.writeString=function(e,t){if(typeof e!=="string")throw new TypeError("argument must be a string (was: "+typeof e+")");if(typeof t!=="number")t=r.OctetString;const n=Buffer.byteLength(e);this.writeByte(t);this.writeLength(n);if(n){this._ensure(n);this._buf.write(e,this._offset);this._offset+=n}};Writer.prototype.writeBuffer=function(e,t){if(typeof t!=="number")throw new TypeError("tag must be a number");if(!Buffer.isBuffer(e))throw new TypeError("argument must be a buffer");this.writeByte(t);this.writeLength(e.length);this._ensure(e.length);e.copy(this._buf,this._offset,0,e.length);this._offset+=e.length};Writer.prototype.writeStringArray=function(e){if(!e instanceof Array)throw new TypeError("argument must be an Array[String]");const t=this;e.forEach((function(e){t.writeString(e)}))};Writer.prototype.writeOID=function(e,t){if(typeof e!=="string")throw new TypeError("argument must be a string");if(typeof t!=="number")t=r.OID;if(!/^([0-9]+\.){3,}[0-9]+$/.test(e))throw new Error("argument is not a valid OID string");function encodeOctet(e,t){if(t<128){e.push(t)}else if(t<16384){e.push(t>>>7|128);e.push(t&127)}else if(t<2097152){e.push(t>>>14|128);e.push((t>>>7|128)&255);e.push(t&127)}else if(t<268435456){e.push(t>>>21|128);e.push((t>>>14|128)&255);e.push((t>>>7|128)&255);e.push(t&127)}else{e.push((t>>>28|128)&255);e.push((t>>>21|128)&255);e.push((t>>>14|128)&255);e.push((t>>>7|128)&255);e.push(t&127)}}const n=e.split(".");const i=[];i.push(parseInt(n[0],10)*40+parseInt(n[1],10));n.slice(2).forEach((function(e){encodeOctet(i,parseInt(e,10))}));const s=this;this._ensure(2+i.length);this.writeByte(t);this.writeLength(i.length);i.forEach((function(e){s.writeByte(e)}))};Writer.prototype.writeLength=function(e){if(typeof e!=="number")throw new TypeError("argument must be a Number");this._ensure(4);if(e<=127){this._buf[this._offset++]=e}else if(e<=255){this._buf[this._offset++]=129;this._buf[this._offset++]=e}else if(e<=65535){this._buf[this._offset++]=130;this._buf[this._offset++]=e>>8;this._buf[this._offset++]=e}else if(e<=16777215){this._buf[this._offset++]=131;this._buf[this._offset++]=e>>16;this._buf[this._offset++]=e>>8;this._buf[this._offset++]=e}else{throw o("Length too long (> 4 bytes)")}};Writer.prototype.startSequence=function(e){if(typeof e!=="number")e=r.Sequence|r.Constructor;this.writeByte(e);this._seq.push(this._offset);this._ensure(3);this._offset+=3};Writer.prototype.endSequence=function(){const e=this._seq.pop();const t=e+3;const n=this._offset-t;if(n<=127){this._shift(t,n,-2);this._buf[e]=n}else if(n<=255){this._shift(t,n,-1);this._buf[e]=129;this._buf[e+1]=n}else if(n<=65535){this._buf[e]=130;this._buf[e+1]=n>>8;this._buf[e+2]=n}else if(n<=16777215){this._shift(t,n,1);this._buf[e]=131;this._buf[e+1]=n>>16;this._buf[e+2]=n>>8;this._buf[e+3]=n}else{throw o("Sequence too long")}};Writer.prototype._shift=function(e,t,n){i.ok(e!==undefined);i.ok(t!==undefined);i.ok(n);this._buf.copy(this._buf,e+n,e,e+t);this._offset+=n};Writer.prototype._ensure=function(e){i.ok(e);if(this._size-this._offset<e){let t=this._size*this._options.growthFactor;if(t-this._offset<e)t+=e;const n=Buffer.alloc(t);this._buf.copy(n,0,0,this._offset);this._buf=n;this._size=t}};e.exports=Writer},461:(e,t,n)=>{const i=n(959);e.exports={Ber:i,BerReader:i.Reader,BerWriter:i.Writer}},645:(e,t,n)=>{const{Duplex:i,Readable:r,Writable:s}=n(781);const{CHANNEL_EXTENDED_DATATYPE:{STDERR:o}}=n(434);const{bufferSlice:f}=n(223);const h=32*1024;const l=2*1024*1024;const u=l/2;class ClientStderr extends r{constructor(e,t){super(t);this._channel=e}_read(e){if(this._channel._waitChanDrain){this._channel._waitChanDrain=false;if(this._channel.incoming.window<=u)windowAdjust(this._channel)}}}class ServerStderr extends s{constructor(e){super({highWaterMark:l});this._channel=e}_write(e,t,n){const i=this._channel;const r=i._client._protocol;const s=i.outgoing;const h=s.packetSize;const l=s.id;let u=s.window;const A=e.length;let g=0;if(s.state!=="open")return;while(A-g>0&&u>0){let t=A-g;if(t>u)t=u;if(t>h)t=h;if(g===0&&t===A)r.channelExtData(l,e,o);else r.channelExtData(l,f(e,g,g+t),o);g+=t;u-=t}s.window=u;if(A-g>0){if(u===0)i._waitWindow=true;if(g>0)i._chunkErr=f(e,g,A);else i._chunkErr=e;i._chunkcbErr=n;return}n()}}class Channel extends i{constructor(e,t,n){const i={highWaterMark:l,allowHalfOpen:!n||n&&n.allowHalfOpen!==false,emitClose:false};super(i);this.allowHalfOpen=i.allowHalfOpen;const r=!!(n&&n.server);this.server=r;this.type=t.type;this.subtype=undefined;this.incoming=t.incoming;this.outgoing=t.outgoing;this._callbacks=[];this._client=e;this._hasX11=false;this._exit={code:undefined,signal:undefined,dump:undefined,desc:undefined};this.stdin=this.stdout=this;if(r)this.stderr=new ServerStderr(this);else this.stderr=new ClientStderr(this,i);this._waitWindow=false;this._waitChanDrain=false;this._chunk=undefined;this._chunkcb=undefined;this._chunkErr=undefined;this._chunkcbErr=undefined;this.on("finish",onFinish).on("prefinish",onFinish);this.on("end",onEnd).on("close",onEnd)}_read(e){if(this._waitChanDrain){this._waitChanDrain=false;if(this.incoming.window<=u)windowAdjust(this)}}_write(e,t,n){const i=this._client._protocol;const r=this.outgoing;const s=r.packetSize;const o=r.id;let h=r.window;const l=e.length;let u=0;if(r.state!=="open")return;while(l-u>0&&h>0){let t=l-u;if(t>h)t=h;if(t>s)t=s;if(u===0&&t===l)i.channelData(o,e);else i.channelData(o,f(e,u,u+t));u+=t;h-=t}r.window=h;if(l-u>0){if(h===0)this._waitWindow=true;if(u>0)this._chunk=f(e,u,l);else this._chunk=e;this._chunkcb=n;return}n()}eof(){if(this.outgoing.state==="open"){this.outgoing.state="eof";this._client._protocol.channelEOF(this.outgoing.id)}}close(){if(this.outgoing.state==="open"||this.outgoing.state==="eof"){this.outgoing.state="closing";this._client._protocol.channelClose(this.outgoing.id)}}destroy(){this.end();this.close()}setWindow(e,t,n,i){if(this.server)throw new Error("Client-only method called in server mode");if(this.type==="session"&&(this.subtype==="shell"||this.subtype==="exec")&&this.writable&&this.outgoing.state==="open"){this._client._protocol.windowChange(this.outgoing.id,e,t,n,i)}}signal(e){if(this.server)throw new Error("Client-only method called in server mode");if(this.type==="session"&&this.writable&&this.outgoing.state==="open"){this._client._protocol.signal(this.outgoing.id,e)}}exit(e,t,n){if(!this.server)throw new Error("Server-only method called in client mode");if(this.type==="session"&&this.writable&&this.outgoing.state==="open"){if(typeof e==="number"){this._client._protocol.exitStatus(this.outgoing.id,e)}else{this._client._protocol.exitSignal(this.outgoing.id,e,t,n)}}}}function onFinish(){this.eof();if(this.server||!this.allowHalfOpen)this.close();this.writable=false}function onEnd(){this.readable=false}function windowAdjust(e){if(e.outgoing.state==="closed")return;const t=l-e.incoming.window;if(t<=0)return;e.incoming.window+=t;e._client._protocol.channelWindowAdjust(e.outgoing.id,t)}e.exports={Channel:Channel,MAX_WINDOW:l,PACKET_SIZE:h,windowAdjust:windowAdjust,WINDOW_THRESHOLD:u}},507:(e,t,n)=>{const{createHash:i,getHashes:r,randomFillSync:s}=n(113);const{Socket:o}=n(808);const{lookup:f}=n(523);const h=n(361);const l=r();const{COMPAT:u,CHANNEL_EXTENDED_DATATYPE:{STDERR:A},CHANNEL_OPEN_FAILURE:g,DEFAULT_CIPHER:_,DEFAULT_COMPRESSION:p,DEFAULT_KEX:E,DEFAULT_MAC:b,DEFAULT_SERVER_HOST_KEY:S,DISCONNECT_REASON:y,DISCONNECT_REASON_BY_VALUE:m,SUPPORTED_CIPHER:w,SUPPORTED_COMPRESSION:C,SUPPORTED_KEX:B,SUPPORTED_MAC:k,SUPPORTED_SERVER_HOST_KEY:R}=n(434);const{init:N}=n(298);const T=n(290);const{parseKey:P}=n(887);const{SFTP:U}=n(58);const{bufferCopy:Q,makeBufferParser:L,makeError:O,readUInt32BE:D,sigSSHToASN1:v,writeUInt32BE:H}=n(223);const{AgentContext:F,createAgent:W,isAgent:x}=n(55);const{Channel:M,MAX_WINDOW:q,PACKET_SIZE:G,windowAdjust:$,WINDOW_THRESHOLD:Y}=n(645);const{ChannelManager:j,generateAlgorithmList:V,isWritable:z,onChannelOpenFailure:ee,onCHANNEL_CLOSE:te}=n(283);const ne=L();const ie=L();const re=/^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/;const noop=()=>{};class Client extends h{constructor(){super();this.config={host:undefined,port:undefined,localAddress:undefined,localPort:undefined,forceIPv4:undefined,forceIPv6:undefined,keepaliveCountMax:undefined,keepaliveInterval:undefined,readyTimeout:undefined,ident:undefined,username:undefined,password:undefined,privateKey:undefined,tryKeyboard:undefined,agent:undefined,allowAgentFwd:undefined,authHandler:undefined,hostHashAlgo:undefined,hostHashCb:undefined,strictVendor:undefined,debug:undefined};this._agent=undefined;this._readyTimeout=undefined;this._chanMgr=undefined;this._callbacks=undefined;this._forwarding=undefined;this._forwardingUnix=undefined;this._acceptX11=undefined;this._agentFwdEnabled=undefined;this._remoteVer=undefined;this._protocol=undefined;this._sock=undefined;this._resetKA=undefined}connect(e){if(this._sock&&z(this._sock)){this.once("close",(()=>{this.connect(e)}));this.end();return this}this.config.host=e.hostname||e.host||"localhost";this.config.port=e.port||22;this.config.localAddress=typeof e.localAddress==="string"?e.localAddress:undefined;this.config.localPort=typeof e.localPort==="string"||typeof e.localPort==="number"?e.localPort:undefined;this.config.forceIPv4=e.forceIPv4||false;this.config.forceIPv6=e.forceIPv6||false;this.config.keepaliveCountMax=typeof e.keepaliveCountMax==="number"&&e.keepaliveCountMax>=0?e.keepaliveCountMax:3;this.config.keepaliveInterval=typeof e.keepaliveInterval==="number"&&e.keepaliveInterval>0?e.keepaliveInterval:0;this.config.readyTimeout=typeof e.readyTimeout==="number"&&e.readyTimeout>=0?e.readyTimeout:2e4;this.config.ident=typeof e.ident==="string"||Buffer.isBuffer(e.ident)?e.ident:undefined;const t={kex:undefined,serverHostKey:undefined,cs:{cipher:undefined,mac:undefined,compress:undefined,lang:[]},sc:undefined};let n=true;if(typeof e.algorithms==="object"&&e.algorithms!==null){t.kex=V(e.algorithms.kex,E,B);if(t.kex!==E)n=false;t.serverHostKey=V(e.algorithms.serverHostKey,S,R);if(t.serverHostKey!==S)n=false;t.cs.cipher=V(e.algorithms.cipher,_,w);if(t.cs.cipher!==_)n=false;t.cs.mac=V(e.algorithms.hmac,b,k);if(t.cs.mac!==b)n=false;t.cs.compress=V(e.algorithms.compress,p,C);if(t.cs.compress!==p)n=false;if(!n)t.sc=t.cs}if(typeof e.username==="string")this.config.username=e.username;else if(typeof e.user==="string")this.config.username=e.user;else throw new Error("Invalid username");this.config.password=typeof e.password==="string"?e.password:undefined;this.config.privateKey=typeof e.privateKey==="string"||Buffer.isBuffer(e.privateKey)?e.privateKey:undefined;this.config.localHostname=typeof e.localHostname==="string"?e.localHostname:undefined;this.config.localUsername=typeof e.localUsername==="string"?e.localUsername:undefined;this.config.tryKeyboard=e.tryKeyboard===true;if(typeof e.agent==="string"&&e.agent.length)this.config.agent=W(e.agent);else if(x(e.agent))this.config.agent=e.agent;else this.config.agent=undefined;this.config.allowAgentFwd=e.agentForward===true&&this.config.agent!==undefined;let r=this.config.authHandler=typeof e.authHandler==="function"||Array.isArray(e.authHandler)?e.authHandler:undefined;this.config.strictVendor=typeof e.strictVendor==="boolean"?e.strictVendor:true;const s=this.config.debug=typeof e.debug==="function"?e.debug:undefined;if(e.agentForward===true&&!this.config.allowAgentFwd){throw new Error("You must set a valid agent path to allow agent forwarding")}let h=this._callbacks=[];this._chanMgr=new j(this);this._forwarding={};this._forwardingUnix={};this._acceptX11=0;this._agentFwdEnabled=false;this._agent=this.config.agent?this.config.agent:undefined;this._remoteVer=undefined;let u;if(this.config.privateKey){u=P(this.config.privateKey,e.passphrase);if(u instanceof Error)throw new Error(`Cannot parse privateKey: ${u.message}`);if(Array.isArray(u)){u=u[0]}if(u.getPrivatePEM()===null){throw new Error("privateKey value does not contain a (valid) private key")}}let g;if(typeof e.hostVerifier==="function"){const t=e.hostVerifier;let n;if(l.indexOf(e.hostHash)!==-1){n=i(e.hostHash)}g=(e,i)=>{if(n){n.update(e);e=n.digest("hex")}const r=t(e,i);if(r!==undefined)i(r)}}const Q=this._sock=e.sock||new o;let L=false;let D=false;if(this._protocol)this._protocol.cleanup();const v=!s?undefined:(e,t,n)=>{s(`Debug output from server: ${JSON.stringify(n)}`)};const H=this._protocol=new T({ident:this.config.ident,offer:n?undefined:t,onWrite:e=>{if(z(Q))Q.write(e)},onError:e=>{if(e.level==="handshake")clearTimeout(this._readyTimeout);if(!H._destruct)Q.removeAllListeners("data");this.emit("error",e);try{Q.end()}catch{}},onHeader:e=>{D=true;this._remoteVer=e.versions.software;if(e.greeting)this.emit("greeting",e.greeting)},onHandshakeComplete:e=>{this.emit("handshake",e);if(!L){L=true;H.service("ssh-userauth")}},debug:s,hostVerifier:g,messageHandlers:{DEBUG:v,DISCONNECT:(e,t,n)=>{if(t!==y.BY_APPLICATION){if(!n){n=m[t];if(n===undefined)n=`Unexpected disconnection reason: ${t}`}const e=new Error(n);e.code=t;this.emit("error",e)}Q.end()},SERVICE_ACCEPT:(e,t)=>{if(t==="ssh-userauth")tryNextAuth()},USERAUTH_BANNER:(e,t)=>{this.emit("banner",t)},USERAUTH_SUCCESS:e=>{resetKA();clearTimeout(this._readyTimeout);this.emit("ready")},USERAUTH_FAILURE:(e,t,n)=>{if(fe.type==="agent"){const e=fe.agentCtx.pos();s&&s(`Client: Agent key #${e+1} failed`);return tryNextAgentKey()}s&&s(`Client: ${fe.type} auth failed`);he=n;le=t;tryNextAuth()},USERAUTH_PASSWD_CHANGEREQ:(e,t)=>{if(fe.type==="password"){this.emit("change password",t,(e=>{H.authPassword(this.config.username,this.config.password,e)}))}},USERAUTH_PK_OK:e=>{if(fe.type==="agent"){const e=fe.agentCtx.currentKey();H.authPK(fe.username,e,((t,n)=>{fe.agentCtx.sign(e,t,{},((e,t)=>{if(e){e.level="agent";this.emit("error",e)}else{return n(t)}tryNextAgentKey()}))}))}else if(fe.type==="publickey"){H.authPK(fe.username,fe.key,((e,t)=>{const n=fe.key.sign(e);if(n instanceof Error){n.message=`Error signing data with key: ${n.message}`;n.level="client-authentication";this.emit("error",n);return tryNextAuth()}t(n)}))}},USERAUTH_INFO_REQUEST:(e,t,n,i)=>{if(fe.type==="keyboard-interactive"){const e=Array.isArray(i)?i.length:0;if(e===0){s&&s("Client: Sending automatic USERAUTH_INFO_RESPONSE");H.authInfoRes();return}fe.prompt(t,n,"",i,(e=>{H.authInfoRes(e)}))}},REQUEST_SUCCESS:(e,t)=>{if(h.length)h.shift()(false,t)},REQUEST_FAILURE:e=>{if(h.length)h.shift()(true)},GLOBAL_REQUEST:(e,t,n,i)=>{switch(t){case"hostkeys-00@openssh.com":hostKeysProve(this,i,((e,t)=>{if(e)return;this.emit("hostkeys",t)}));if(n)H.requestSuccess();break;default:if(n)H.requestFailure()}},CHANNEL_OPEN:(e,t)=>{onCHANNEL_OPEN(this,t)},CHANNEL_OPEN_CONFIRMATION:(e,t)=>{const n=this._chanMgr.get(t.recipient);if(typeof n!=="function")return;const i=n.type==="sftp";const r=i?"session":n.type;const o={type:r,incoming:{id:t.recipient,window:q,packetSize:G,state:"open"},outgoing:{id:t.sender,window:t.window,packetSize:t.packetSize,state:"open"}};const f=i?new U(this,o,{debug:s}):new M(this,o);this._chanMgr.update(t.recipient,f);n(undefined,f)},CHANNEL_OPEN_FAILURE:(e,t,n,i)=>{const r=this._chanMgr.get(t);if(typeof r!=="function")return;const s={reason:n,description:i};ee(this,t,s,r)},CHANNEL_DATA:(e,t,n)=>{const i=this._chanMgr.get(t);if(typeof i!=="object"||i===null)return;if(i.incoming.window===0)return;i.incoming.window-=n.length;if(i.push(n)===false){i._waitChanDrain=true;return}if(i.incoming.window<=Y)$(i)},CHANNEL_EXTENDED_DATA:(e,t,n,i)=>{if(i!==A)return;const r=this._chanMgr.get(t);if(typeof r!=="object"||r===null)return;if(r.incoming.window===0)return;r.incoming.window-=n.length;if(!r.stderr.push(n)){r._waitChanDrain=true;return}if(r.incoming.window<=Y)$(r)},CHANNEL_WINDOW_ADJUST:(e,t,n)=>{const i=this._chanMgr.get(t);if(typeof i!=="object"||i===null)return;i.outgoing.window+=n;if(i._waitWindow){i._waitWindow=false;if(i._chunk){i._write(i._chunk,null,i._chunkcb)}else if(i._chunkcb){i._chunkcb()}else if(i._chunkErr){i.stderr._write(i._chunkErr,null,i._chunkcbErr)}else if(i._chunkcbErr){i._chunkcbErr()}}},CHANNEL_SUCCESS:(e,t)=>{const n=this._chanMgr.get(t);if(typeof n!=="object"||n===null)return;this._resetKA();if(n._callbacks.length)n._callbacks.shift()(false)},CHANNEL_FAILURE:(e,t)=>{const n=this._chanMgr.get(t);if(typeof n!=="object"||n===null)return;this._resetKA();if(n._callbacks.length)n._callbacks.shift()(true)},CHANNEL_REQUEST:(e,t,n,i,r)=>{const s=this._chanMgr.get(t);if(typeof s!=="object"||s===null)return;const o=s._exit;if(o.code!==undefined)return;switch(n){case"exit-status":s.emit("exit",o.code=r);return;case"exit-signal":s.emit("exit",o.code=null,o.signal=`SIG${r.signal}`,o.dump=r.coreDumped,o.desc=r.errorMessage);return}if(i)e.channelFailure(s.outgoing.id)},CHANNEL_EOF:(e,t)=>{const n=this._chanMgr.get(t);if(typeof n!=="object"||n===null)return;if(n.incoming.state!=="open")return;n.incoming.state="eof";if(n.readable)n.push(null);if(n.stderr.readable)n.stderr.push(null)},CHANNEL_CLOSE:(e,t)=>{te(this,t,this._chanMgr.get(t))}}});Q.pause();const ne=this.config.keepaliveInterval;const ie=this.config.keepaliveCountMax;let re=0;let se;const sendKA=()=>{if(++re>ie){clearInterval(se);if(Q.readable){const e=new Error("Keepalive timeout");e.level="client-timeout";this.emit("error",e);Q.destroy()}return}if(z(Q)){h.push(resetKA);H.ping()}else{clearInterval(se)}};function resetKA(){if(ne>0){re=0;clearInterval(se);if(z(Q))se=setInterval(sendKA,ne)}}this._resetKA=resetKA;const oe=(()=>{let e=false;return()=>{if(e)return;e=true;if(ce&&!D){const e=O("Connection lost before handshake","protocol",true);this.emit("error",e)}}})();const ae=(()=>{let e=false;return()=>{if(e)return;e=true;ce=true;s&&s("Socket connected");this.emit("connect");N.then((()=>{Q.on("data",(e=>{try{H.parse(e,0,e.length)}catch(e){this.emit("error",e);try{if(z(Q))Q.end()}catch{}}}));if(Q.stderr&&typeof Q.stderr.resume==="function")Q.stderr.resume();Q.resume()})).catch((e=>{this.emit("error",e);try{if(z(Q))Q.end()}catch{}}))}})();let ce=false;Q.on("connect",ae).on("timeout",(()=>{this.emit("timeout")})).on("error",(e=>{s&&s(`Socket error: ${e.message}`);clearTimeout(this._readyTimeout);e.level="client-socket";this.emit("error",e)})).on("end",(()=>{s&&s("Socket ended");oe();H.cleanup();clearTimeout(this._readyTimeout);clearInterval(se);this.emit("end")})).on("close",(()=>{s&&s("Socket closed");oe();H.cleanup();clearTimeout(this._readyTimeout);clearInterval(se);this.emit("close");const e=h;h=this._callbacks=[];const t=new Error("No response from server");for(let n=0;n<e.length;++n)e[n](t);this._chanMgr.cleanup(t)}));let fe;let he=null;let le=null;const ue=["none"];if(this.config.password!==undefined)ue.push("password");if(u!==undefined)ue.push("publickey");if(this._agent!==undefined)ue.push("agent");if(this.config.tryKeyboard)ue.push("keyboard-interactive");if(u!==undefined&&this.config.localHostname!==undefined&&this.config.localUsername!==undefined){ue.push("hostbased")}if(Array.isArray(r))r=makeSimpleAuthHandler(r);else if(typeof r!=="function")r=makeSimpleAuthHandler(ue);let de=false;const doNextAuth=e=>{if(de)return;de=true;if(e===false){const e=new Error("All configured authentication methods failed");e.level="client-authentication";this.emit("error",e);this.end();return}if(typeof e==="string"){const t=e;if(ue.indexOf(t)===-1)return skipAuth(`Authentication method not allowed: ${t}`);const n=this.config.username;switch(t){case"password":e={type:t,username:n,password:this.config.password};break;case"publickey":e={type:t,username:n,key:u};break;case"hostbased":e={type:t,username:n,key:u,localHostname:this.config.localHostname,localUsername:this.config.localUsername};break;case"agent":e={type:t,username:n,agentCtx:new F(this._agent)};break;case"keyboard-interactive":e={type:t,username:n,prompt:(...e)=>this.emit("keyboard-interactive",...e)};break;case"none":e={type:t,username:n};break;default:return skipAuth(`Skipping unsupported authentication method: ${e}`)}}else if(typeof e!=="object"||e===null){return skipAuth(`Skipping invalid authentication attempt: ${e}`)}else{const t=e.username;if(typeof t!=="string"){return skipAuth(`Skipping invalid authentication attempt: ${e}`)}const n=e.type;switch(n){case"password":{const{password:i}=e;if(typeof i!=="string"&&!Buffer.isBuffer(i))return skipAuth("Skipping invalid password auth attempt");e={type:n,username:t,password:i};break}case"publickey":{const i=P(e.key,e.passphrase);if(i instanceof Error)return skipAuth("Skipping invalid key auth attempt");if(!i.isPrivateKey())return skipAuth("Skipping non-private key");e={type:n,username:t,key:i};break}case"hostbased":{const{localHostname:i,localUsername:r}=e;const s=P(e.key,e.passphrase);if(s instanceof Error||typeof i!=="string"||typeof r!=="string"){return skipAuth("Skipping invalid hostbased auth attempt")}if(!s.isPrivateKey())return skipAuth("Skipping non-private key");e={type:n,username:t,key:s,localHostname:i,localUsername:r};break}case"agent":{let i=e.agent;if(typeof i==="string"&&i.length){i=W(i)}else if(!x(i)){return skipAuth(`Skipping invalid agent: ${e.agent}`)}e={type:n,username:t,agentCtx:new F(i)};break}case"keyboard-interactive":{const{prompt:i}=e;if(typeof i!=="function"){return skipAuth("Skipping invalid keyboard-interactive auth attempt")}e={type:n,username:t,prompt:i};break}case"none":e={type:n,username:t};break;default:return skipAuth(`Skipping unsupported authentication method: ${e}`)}}fe=e;try{const e=fe.username;switch(fe.type){case"password":H.authPassword(e,fe.password);break;case"publickey":H.authPK(e,fe.key);break;case"hostbased":H.authHostbased(e,fe.key,fe.localHostname,fe.localUsername,((e,t)=>{const n=fe.key.sign(e);if(n instanceof Error){n.message=`Error while signing with key: ${n.message}`;n.level="client-authentication";this.emit("error",n);return tryNextAuth()}t(n)}));break;case"agent":fe.agentCtx.init((e=>{if(e){e.level="agent";this.emit("error",e);return tryNextAuth()}tryNextAgentKey()}));break;case"keyboard-interactive":H.authKeyboard(e);break;case"none":H.authNone(e);break}}finally{de=false}};function skipAuth(e){s&&s(e);process.nextTick(tryNextAuth)}function tryNextAuth(){de=false;const e=r(le,he,doNextAuth);if(de||e===undefined)return;doNextAuth(e)}const tryNextAgentKey=()=>{if(fe.type==="agent"){const e=fe.agentCtx.nextKey();if(e===false){s&&s("Agent: No more keys left to try");s&&s("Client: agent auth failed");tryNextAuth()}else{const t=fe.agentCtx.pos();s&&s(`Agent: Trying key #${t+1}`);H.authPK(fe.username,e)}}};const startTimeout=()=>{if(this.config.readyTimeout>0){this._readyTimeout=setTimeout((()=>{const e=new Error("Timed out while waiting for handshake");e.level="client-timeout";this.emit("error",e);Q.destroy()}),this.config.readyTimeout)}};if(!e.sock){let t=this.config.host;const n=this.config.forceIPv4;const i=this.config.forceIPv6;s&&s(`Client: Trying ${t} on port ${this.config.port} ...`);const doConnect=()=>{startTimeout();Q.connect({host:t,port:this.config.port,localAddress:this.config.localAddress,localPort:this.config.localPort});Q.setNoDelay(true);Q.setMaxListeners(0);Q.setTimeout(typeof e.timeout==="number"?e.timeout:0)};if(!n&&!i||n&&i){doConnect()}else{f(t,n?4:6,((e,i,r)=>{if(e){const i=n?"IPv4":"IPv6";const r=new Error(`Error while looking up ${i} address for '${t}': ${e}`);clearTimeout(this._readyTimeout);r.level="client-dns";this.emit("error",r);this.emit("close");return}t=i;doConnect()}))}}else{startTimeout();if(typeof Q.connecting==="boolean"){if(!Q.connecting){ae()}}else{ae()}}return this}end(){if(this._sock&&z(this._sock)){this._protocol.disconnect(y.BY_APPLICATION);this._sock.end()}return this}destroy(){this._sock&&z(this._sock)&&this._sock.destroy();return this}exec(e,t,n){if(!this._sock||!z(this._sock))throw new Error("Not connected");if(typeof t==="function"){n=t;t={}}const i={allowHalfOpen:t.allowHalfOpen!==false};openChannel(this,"session",i,((i,r)=>{if(i){n(i);return}const s=[];function reqCb(e){if(e){r.close();n(e);return}if(s.length)s.shift()()}if(this.config.allowAgentFwd===true||t&&t.agentForward===true&&this._agent!==undefined){s.push((()=>reqAgentFwd(r,reqCb)))}if(typeof t==="object"&&t!==null){if(typeof t.env==="object"&&t.env!==null)reqEnv(r,t.env);if(typeof t.pty==="object"&&t.pty!==null||t.pty===true){s.push((()=>reqPty(r,t.pty,reqCb)))}if(typeof t.x11==="object"&&t.x11!==null||t.x11==="number"||t.x11===true){s.push((()=>reqX11(r,t.x11,reqCb)))}}s.push((()=>reqExec(r,e,t,n)));s.shift()()}));return this}shell(e,t,n){if(!this._sock||!z(this._sock))throw new Error("Not connected");if(typeof e==="function"){n=e;e=t=undefined}else if(typeof t==="function"){n=t;t=undefined}if(e&&(e.x11!==undefined||e.env!==undefined)){t=e;e=undefined}openChannel(this,"session",((i,r)=>{if(i){n(i);return}const s=[];function reqCb(e){if(e){r.close();n(e);return}if(s.length)s.shift()()}if(this.config.allowAgentFwd===true||t&&t.agentForward===true&&this._agent!==undefined){s.push((()=>reqAgentFwd(r,reqCb)))}if(e!==false)s.push((()=>reqPty(r,e,reqCb)));if(typeof t==="object"&&t!==null){if(typeof t.env==="object"&&t.env!==null)reqEnv(r,t.env);if(typeof t.x11==="object"&&t.x11!==null||t.x11==="number"||t.x11===true){s.push((()=>reqX11(r,t.x11,reqCb)))}}s.push((()=>reqShell(r,n)));s.shift()()}));return this}subsys(e,t){if(!this._sock||!z(this._sock))throw new Error("Not connected");openChannel(this,"session",((n,i)=>{if(n){t(n);return}reqSubsystem(i,e,((e,n)=>{if(e){t(e);return}t(undefined,n)}))}));return this}forwardIn(e,t,n){if(!this._sock||!z(this._sock))throw new Error("Not connected");const i=typeof n==="function";if(i){this._callbacks.push(((i,r)=>{if(i){n(i!==true?i:new Error(`Unable to bind to ${e}:${t}`));return}let s=t;if(t===0&&r&&r.length>=4){s=D(r,0);if(!(this._protocol._compatFlags&u.DYN_RPORT_BUG))t=s}this._forwarding[`${e}:${t}`]=s;n(undefined,s)}))}this._protocol.tcpipForward(e,t,i);return this}unforwardIn(e,t,n){if(!this._sock||!z(this._sock))throw new Error("Not connected");const i=typeof n==="function";if(i){this._callbacks.push((i=>{if(i){n(i!==true?i:new Error(`Unable to unbind from ${e}:${t}`));return}delete this._forwarding[`${e}:${t}`];n()}))}this._protocol.cancelTcpipForward(e,t,i);return this}forwardOut(e,t,n,i,r){if(!this._sock||!z(this._sock))throw new Error("Not connected");const s={srcIP:e,srcPort:t,dstIP:n,dstPort:i};if(typeof r!=="function")r=noop;openChannel(this,"direct-tcpip",s,r);return this}openssh_noMoreSessions(e){if(!this._sock||!z(this._sock))throw new Error("Not connected");const t=typeof e==="function";if(!this.config.strictVendor||this.config.strictVendor&&re.test(this._remoteVer)){if(t){this._callbacks.push((t=>{if(t){e(t!==true?t:new Error("Unable to disable future sessions"));return}e()}))}this._protocol.openssh_noMoreSessions(t);return this}if(!t)return this;process.nextTick(e,new Error("strictVendor enabled and server is not OpenSSH or compatible version"));return this}openssh_forwardInStreamLocal(e,t){if(!this._sock||!z(this._sock))throw new Error("Not connected");const n=typeof t==="function";if(!this.config.strictVendor||this.config.strictVendor&&re.test(this._remoteVer)){if(n){this._callbacks.push((n=>{if(n){t(n!==true?n:new Error(`Unable to bind to ${e}`));return}this._forwardingUnix[e]=true;t()}))}this._protocol.openssh_streamLocalForward(e,n);return this}if(!n)return this;process.nextTick(t,new Error("strictVendor enabled and server is not OpenSSH or compatible version"));return this}openssh_unforwardInStreamLocal(e,t){if(!this._sock||!z(this._sock))throw new Error("Not connected");const n=typeof t==="function";if(!this.config.strictVendor||this.config.strictVendor&&re.test(this._remoteVer)){if(n){this._callbacks.push((n=>{if(n){t(n!==true?n:new Error(`Unable to unbind from ${e}`));return}delete this._forwardingUnix[e];t()}))}this._protocol.openssh_cancelStreamLocalForward(e,n);return this}if(!n)return this;process.nextTick(t,new Error("strictVendor enabled and server is not OpenSSH or compatible version"));return this}openssh_forwardOutStreamLocal(e,t){if(!this._sock||!z(this._sock))throw new Error("Not connected");if(typeof t!=="function")t=noop;if(!this.config.strictVendor||this.config.strictVendor&&re.test(this._remoteVer)){openChannel(this,"direct-streamlocal@openssh.com",{socketPath:e},t);return this}process.nextTick(t,new Error("strictVendor enabled and server is not OpenSSH or compatible version"));return this}sftp(e){if(!this._sock||!z(this._sock))throw new Error("Not connected");openChannel(this,"sftp",((t,n)=>{if(t){e(t);return}reqSubsystem(n,"sftp",((t,i)=>{if(t){e(t);return}function removeListeners(){n.removeListener("ready",onReady);n.removeListener("error",onError);n.removeListener("exit",onExit);n.removeListener("close",onExit)}function onReady(){removeListeners();e(undefined,n)}function onError(t){removeListeners();e(t)}function onExit(t,n){removeListeners();let i;if(typeof t==="number")i=`Received exit code ${t} while establishing SFTP session`;else if(n!==undefined)i=`Received signal ${n} while establishing SFTP session`;else i="Received unexpected SFTP session termination";const r=new Error(i);r.code=t;r.signal=n;e(r)}n.on("ready",onReady).on("error",onError).on("exit",onExit).on("close",onExit);n._init()}))}));return this}}function openChannel(e,t,n,i){const r=q;const s=G;if(typeof n==="function"){i=n;n={}}const wrapper=(e,t)=>{i(e,t)};wrapper.type=t;const o=e._chanMgr.add(wrapper);if(o===-1){i(new Error("No free channels available"));return}switch(t){case"session":case"sftp":e._protocol.session(o,r,s);break;case"direct-tcpip":e._protocol.directTcpip(o,r,s,n);break;case"direct-streamlocal@openssh.com":e._protocol.openssh_directStreamLocal(o,r,s,n);break;default:throw new Error(`Unsupported channel type: ${t}`)}}function reqX11(e,t,n){const i={single:false,protocol:"MIT-MAGIC-COOKIE-1",cookie:undefined,screen:0};if(typeof t==="function"){n=t}else if(typeof t==="object"&&t!==null){if(typeof t.single==="boolean")i.single=t.single;if(typeof t.screen==="number")i.screen=t.screen;if(typeof t.protocol==="string")i.protocol=t.protocol;if(typeof t.cookie==="string")i.cookie=t.cookie;else if(Buffer.isBuffer(t.cookie))i.cookie=t.cookie.hexSlice(0,t.cookie.length)}if(i.cookie===undefined)i.cookie=se();const r=typeof n==="function";if(e.outgoing.state!=="open"){if(r)n(new Error("Channel is not open"));return}if(r){e._callbacks.push((t=>{if(t){n(t!==true?t:new Error("Unable to request X11"));return}e._hasX11=true;++e._client._acceptX11;e.once("close",(()=>{if(e._client._acceptX11)--e._client._acceptX11}));n()}))}e._client._protocol.x11Forward(e.outgoing.id,i,r)}function reqPty(e,t,n){let i=24;let r=80;let s=640;let o=480;let f="vt100";let h=null;if(typeof t==="function"){n=t}else if(typeof t==="object"&&t!==null){if(typeof t.rows==="number")i=t.rows;if(typeof t.cols==="number")r=t.cols;if(typeof t.width==="number")s=t.width;if(typeof t.height==="number")o=t.height;if(typeof t.term==="string")f=t.term;if(typeof t.modes==="object")h=t.modes}const l=typeof n==="function";if(e.outgoing.state!=="open"){if(l)n(new Error("Channel is not open"));return}if(l){e._callbacks.push((e=>{if(e){n(e!==true?e:new Error("Unable to request a pseudo-terminal"));return}n()}))}e._client._protocol.pty(e.outgoing.id,i,r,o,s,f,h,l)}function reqAgentFwd(e,t){const n=typeof t==="function";if(e.outgoing.state!=="open"){n&&t(new Error("Channel is not open"));return}if(e._client._agentFwdEnabled){n&&t(false);return}e._client._agentFwdEnabled=true;e._callbacks.push((i=>{if(i){e._client._agentFwdEnabled=false;if(n){t(i!==true?i:new Error("Unable to request agent forwarding"))}return}if(n)t()}));e._client._protocol.openssh_agentForward(e.outgoing.id,true)}function reqShell(e,t){if(e.outgoing.state!=="open"){t(new Error("Channel is not open"));return}e._callbacks.push((n=>{if(n){t(n!==true?n:new Error("Unable to open shell"));return}e.subtype="shell";t(undefined,e)}));e._client._protocol.shell(e.outgoing.id,true)}function reqExec(e,t,n,i){if(e.outgoing.state!=="open"){i(new Error("Channel is not open"));return}e._callbacks.push((t=>{if(t){i(t!==true?t:new Error("Unable to exec"));return}e.subtype="exec";e.allowHalfOpen=n.allowHalfOpen!==false;i(undefined,e)}));e._client._protocol.exec(e.outgoing.id,t,true)}function reqEnv(e,t){if(e.outgoing.state!=="open")return;const n=Object.keys(t||{});for(let i=0;i<n.length;++i){const r=n[i];const s=t[r];e._client._protocol.env(e.outgoing.id,r,s,false)}}function reqSubsystem(e,t,n){if(e.outgoing.state!=="open"){n(new Error("Channel is not open"));return}e._callbacks.push((i=>{if(i){n(i!==true?i:new Error(`Unable to start subsystem: ${t}`));return}e.subtype="subsystem";n(undefined,e)}));e._client._protocol.subsystem(e.outgoing.id,t,true)}function onCHANNEL_OPEN(e,t){let n=-1;let i;const accept=()=>{const i={type:t.type,incoming:{id:n,window:q,packetSize:G,state:"open"},outgoing:{id:t.sender,window:t.window,packetSize:t.packetSize,state:"open"}};const r=new M(e,i);e._chanMgr.update(n,r);e._protocol.channelOpenConfirm(t.sender,n,q,G);return r};const reject=()=>{if(i===undefined){if(n===-1)i=g.RESOURCE_SHORTAGE;else i=g.CONNECT_FAILED}if(n!==-1)e._chanMgr.remove(n);e._protocol.channelOpenFail(t.sender,i,"")};const reserveChannel=()=>{n=e._chanMgr.add();if(n===-1){i=g.RESOURCE_SHORTAGE;if(e.config.debug){e.config.debug("Client: Automatic rejection of incoming channel open: "+"no channels available")}}return n!==-1};const r=t.data;switch(t.type){case"forwarded-tcpip":{const t=e._forwarding[`${r.destIP}:${r.destPort}`];if(t!==undefined&&reserveChannel()){if(r.destPort===0)r.destPort=t;e.emit("tcp connection",r,accept,reject);return}break}case"forwarded-streamlocal@openssh.com":if(e._forwardingUnix[r.socketPath]!==undefined&&reserveChannel()){e.emit("unix connection",r,accept,reject);return}break;case"auth-agent@openssh.com":if(e._agentFwdEnabled&&typeof e._agent.getStream==="function"&&reserveChannel()){e._agent.getStream(((e,t)=>{if(e)return reject();const n=accept();n.pipe(t).pipe(n)}));return}break;case"x11":if(e._acceptX11!==0&&reserveChannel()){e.emit("x11",r,accept,reject);return}break;default:i=g.UNKNOWN_CHANNEL_TYPE;if(e.config.debug){e.config.debug("Client: Automatic rejection of unsupported incoming channel open "+`type: ${t.type}`)}}if(i===undefined){i=g.ADMINISTRATIVELY_PROHIBITED;if(e.config.debug){e.config.debug("Client: Automatic rejection of unexpected incoming channel open for: "+t.type)}}reject()}const se=(()=>{const e=Buffer.allocUnsafe(16);return()=>{s(e,0,16);return e.hexSlice(0,16)}})();function makeSimpleAuthHandler(e){if(!Array.isArray(e))throw new Error("authList must be an array");let t=0;return(n,i,r)=>{if(t===e.length)return false;return e[t++]}}function hostKeysProve(e,t,n){if(!e._sock||!z(e._sock))return;if(typeof n!=="function")n=noop;if(!Array.isArray(t))throw new TypeError("Invalid keys argument type");const i=[];for(const e of t){const t=P(e);if(t instanceof Error)throw t;i.push(t)}if(!e.config.strictVendor||e.config.strictVendor&&re.test(e._remoteVer)){e._callbacks.push(((t,r)=>{if(t){n(t!==true?t:new Error("Server failed to prove supplied keys"));return}const s=[];let o=0;ne.init(r,0);while(ne.avail()){if(o===i.length)break;const t=i[o++];const n=t.getPublicSSH();const r=ne.readString();ie.init(r,0);const f=ie.readString(true);let h=ie.readString();let l;if(f!==t.type){if(t.type==="ssh-rsa"){switch(f){case"rsa-sha2-256":l="sha256";break;case"rsa-sha2-512":l="sha512";break;default:continue}}else{continue}}const u=e._protocol._kex.sessionID;const A=Buffer.allocUnsafe(4+29+4+u.length+4+n.length);let g=0;H(A,29,g);A.utf8Write("hostkeys-prove-00@openssh.com",g+=4,29);H(A,u.length,g+=29);Q(u,A,0,u.length,g+=4);H(A,n.length,g+=u.length);Q(n,A,0,n.length,g+=4);if(!(h=v(h,f)))continue;if(t.verify(A,h,l)===true)s.push(t)}ie.clear();ne.clear();n(null,s)}));e._protocol.openssh_hostKeysProve(i);return}process.nextTick(n,new Error("strictVendor enabled and server is not OpenSSH or compatible version"))}e.exports=Client},839:(e,t,n)=>{const{Agent:i}=n(685);const{Agent:r}=n(687);const{connect:s}=n(404);let o;for(const e of[i,r]){class SSHAgent extends e{constructor(e,t){super(t);this._connectCfg=e;this._defaultSrcIP=t&&t.srcIP||"localhost"}createConnection(t,i){const r=t&&t.localAddress||this._defaultSrcIP;const s=t&&t.localPort||0;const f=t.host;const h=t.port;if(o===undefined)o=n(507);const l=new o;let u=false;l.on("ready",(()=>{l.forwardOut(r,s,f,h,((n,r)=>{u=true;if(n){l.end();return i(n)}r.once("close",(()=>l.end()));i(null,decorateStream(r,e,t))}))})).on("error",i).on("close",(()=>{if(!u)i(new Error("Unexpected connection close"))})).connect(this._connectCfg)}}t[e===i?"SSHTTPAgent":"SSHTTPSAgent"]=SSHAgent}function noop(){}function decorateStream(e,t,n){if(t===i){e.setKeepAlive=noop;e.setNoDelay=noop;e.setTimeout=noop;e.ref=noop;e.unref=noop;e.destroySoon=e.destroy;return e}n.socket=e;const r=s(n);const o=(()=>{let t=false;return()=>{if(t)return;t=true;if(e.isPaused())e.resume()}})();r.on("end",o).on("close",o);return r}},648:(e,t,n)=>{const{AgentProtocol:i,BaseAgent:r,createAgent:s,OpenSSHAgent:o}=n(55);const{SSHTTPAgent:f,SSHTTPSAgent:h}=n(839);const{parseKey:l}=n(887);const{flagsToString:u,OPEN_MODE:A,STATUS_CODE:g,stringToFlags:_}=n(58);e.exports={AgentProtocol:i,BaseAgent:r,createAgent:s,Client:n(507),HTTPAgent:f,HTTPSAgent:h,OpenSSHAgent:o,utils:{parseKey:l,sftp:{flagsToString:u,OPEN_MODE:A,STATUS_CODE:g,stringToFlags:_}}}},434:(e,t,n)=>{const i=n(113);let r;const{bindingAvailable:s}=n(298);const o=(()=>{if(typeof i.sign==="function"&&typeof i.verify==="function"){const e="-----BEGIN PRIVATE KEY-----\r\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD"+"/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r\n-----END PRIVATE KEY-----";const t=Buffer.from("a");let n;let r;try{n=i.sign(null,t,e);r=i.verify(null,t,e,n)}catch{}return Buffer.isBuffer(n)&&n.length===64&&r===true}return false})();const f=typeof i.diffieHellman==="function"&&typeof i.generateKeyPairSync==="function"&&typeof i.createPublicKey==="function";const h=["ecdh-sha2-nistp256","ecdh-sha2-nistp384","ecdh-sha2-nistp521","diffie-hellman-group-exchange-sha256","diffie-hellman-group14-sha256","diffie-hellman-group15-sha512","diffie-hellman-group16-sha512","diffie-hellman-group17-sha512","diffie-hellman-group18-sha512"];if(f){h.unshift("curve25519-sha256");h.unshift("curve25519-sha256@libssh.org")}const l=h.concat(["diffie-hellman-group-exchange-sha1","diffie-hellman-group14-sha1","diffie-hellman-group1-sha1"]);const u=["ecdsa-sha2-nistp256","ecdsa-sha2-nistp384","ecdsa-sha2-nistp521","rsa-sha2-512","rsa-sha2-256","ssh-rsa"];if(o)u.unshift("ssh-ed25519");const A=u.concat(["ssh-dss"]);const g=["aes128-gcm","aes128-gcm@openssh.com","aes256-gcm","aes256-gcm@openssh.com","aes128-ctr","aes192-ctr","aes256-ctr"];if(r&&r.flags&&!r.flags.aes){if(s)g.unshift("chacha20-poly1305@openssh.com");else g.push("chacha20-poly1305@openssh.com")}else if(s&&r&&r.arch==="x86"){g.splice(4,0,"chacha20-poly1305@openssh.com")}else{g.push("chacha20-poly1305@openssh.com")}const _=g.concat(["aes256-cbc","aes192-cbc","aes128-cbc","blowfish-cbc","3des-cbc","arcfour256","arcfour128","cast128-cbc","arcfour"]);const p=["hmac-sha2-256-etm@openssh.com","hmac-sha2-512-etm@openssh.com","hmac-sha1-etm@openssh.com","hmac-sha2-256","hmac-sha2-512","hmac-sha1"];const E=p.concat(["hmac-md5","hmac-sha2-256-96","hmac-sha2-512-96","hmac-ripemd160","hmac-sha1-96","hmac-md5-96"]);const b=["none","zlib@openssh.com","zlib"];const S=b.concat([]);const y={BAD_DHGEX:1<<0,OLD_EXIT:1<<1,DYN_RPORT_BUG:1<<2,BUG_DHGEX_LARGE:1<<3};e.exports={MESSAGE:{DISCONNECT:1,IGNORE:2,UNIMPLEMENTED:3,DEBUG:4,SERVICE_REQUEST:5,SERVICE_ACCEPT:6,KEXINIT:20,NEWKEYS:21,KEXDH_INIT:30,KEXDH_REPLY:31,KEXDH_GEX_GROUP:31,KEXDH_GEX_INIT:32,KEXDH_GEX_REPLY:33,KEXDH_GEX_REQUEST:34,KEXECDH_INIT:30,KEXECDH_REPLY:31,USERAUTH_REQUEST:50,USERAUTH_FAILURE:51,USERAUTH_SUCCESS:52,USERAUTH_BANNER:53,USERAUTH_PASSWD_CHANGEREQ:60,USERAUTH_PK_OK:60,USERAUTH_INFO_REQUEST:60,USERAUTH_INFO_RESPONSE:61,GLOBAL_REQUEST:80,REQUEST_SUCCESS:81,REQUEST_FAILURE:82,CHANNEL_OPEN:90,CHANNEL_OPEN_CONFIRMATION:91,CHANNEL_OPEN_FAILURE:92,CHANNEL_WINDOW_ADJUST:93,CHANNEL_DATA:94,CHANNEL_EXTENDED_DATA:95,CHANNEL_EOF:96,CHANNEL_CLOSE:97,CHANNEL_REQUEST:98,CHANNEL_SUCCESS:99,CHANNEL_FAILURE:100},DISCONNECT_REASON:{HOST_NOT_ALLOWED_TO_CONNECT:1,PROTOCOL_ERROR:2,KEY_EXCHANGE_FAILED:3,RESERVED:4,MAC_ERROR:5,COMPRESSION_ERROR:6,SERVICE_NOT_AVAILABLE:7,PROTOCOL_VERSION_NOT_SUPPORTED:8,HOST_KEY_NOT_VERIFIABLE:9,CONNECTION_LOST:10,BY_APPLICATION:11,TOO_MANY_CONNECTIONS:12,AUTH_CANCELED_BY_USER:13,NO_MORE_AUTH_METHODS_AVAILABLE:14,ILLEGAL_USER_NAME:15},DISCONNECT_REASON_STR:undefined,CHANNEL_OPEN_FAILURE:{ADMINISTRATIVELY_PROHIBITED:1,CONNECT_FAILED:2,UNKNOWN_CHANNEL_TYPE:3,RESOURCE_SHORTAGE:4},TERMINAL_MODE:{TTY_OP_END:0,VINTR:1,VQUIT:2,VERASE:3,VKILL:4,VEOF:5,VEOL:6,VEOL2:7,VSTART:8,VSTOP:9,VSUSP:10,VDSUSP:11,VREPRINT:12,VWERASE:13,VLNEXT:14,VFLUSH:15,VSWTCH:16,VSTATUS:17,VDISCARD:18,IGNPAR:30,PARMRK:31,INPCK:32,ISTRIP:33,INLCR:34,IGNCR:35,ICRNL:36,IUCLC:37,IXON:38,IXANY:39,IXOFF:40,IMAXBEL:41,ISIG:50,ICANON:51,XCASE:52,ECHO:53,ECHOE:54,ECHOK:55,ECHONL:56,NOFLSH:57,TOSTOP:58,IEXTEN:59,ECHOCTL:60,ECHOKE:61,PENDIN:62,OPOST:70,OLCUC:71,ONLCR:72,OCRNL:73,ONOCR:74,ONLRET:75,CS7:90,CS8:91,PARENB:92,PARODD:93,TTY_OP_ISPEED:128,TTY_OP_OSPEED:129},CHANNEL_EXTENDED_DATATYPE:{STDERR:1},SIGNALS:["ABRT","ALRM","FPE","HUP","ILL","INT","QUIT","SEGV","TERM","USR1","USR2","KILL","PIPE"].reduce(((e,t)=>({...e,[t]:1})),{}),COMPAT:y,COMPAT_CHECKS:[["Cisco-1.25",y.BAD_DHGEX],[/^Cisco-1\./,y.BUG_DHGEX_LARGE],[/^[0-9.]+$/,y.OLD_EXIT],[/^OpenSSH_5\.\d+/,y.DYN_RPORT_BUG]],DEFAULT_KEX:h,SUPPORTED_KEX:l,DEFAULT_SERVER_HOST_KEY:u,SUPPORTED_SERVER_HOST_KEY:A,DEFAULT_CIPHER:g,SUPPORTED_CIPHER:_,DEFAULT_MAC:p,SUPPORTED_MAC:E,DEFAULT_COMPRESSION:b,SUPPORTED_COMPRESSION:S,curve25519Supported:f,eddsaSupported:o};e.exports.DISCONNECT_REASON_BY_VALUE=Array.from(Object.entries(e.exports.DISCONNECT_REASON)).reduce(((e,[t,n])=>({...e,[n]:t})),{})},298:(e,t,n)=>{const{createCipheriv:i,createDecipheriv:r,createHmac:s,randomFillSync:o,timingSafeEqual:f}=n(113);const{readUInt32BE:h,writeUInt32BE:l}=n(223);const u=Buffer[Symbol.species];const A=2**32-1;const g=Buffer.alloc(0);const _=Buffer.alloc(4);const p=new Map;const E=35e3;let b;let S;let y;let m;let w;let C;let B;const k=1<<0;const R=(()=>{function info(e,t,n,i,r,s,o){return{sslName:e,blockLen:t,keyLen:n,ivLen:i!==0||o&k?i:t,authLen:r,discardLen:s,stream:!!(o&k)}}return{"chacha20-poly1305@openssh.com":info("chacha20",8,64,0,16,0,k),"aes128-gcm":info("aes-128-gcm",16,16,12,16,0,k),"aes256-gcm":info("aes-256-gcm",16,32,12,16,0,k),"aes128-gcm@openssh.com":info("aes-128-gcm",16,16,12,16,0,k),"aes256-gcm@openssh.com":info("aes-256-gcm",16,32,12,16,0,k),"aes128-cbc":info("aes-128-cbc",16,16,0,0,0,0),"aes192-cbc":info("aes-192-cbc",16,24,0,0,0,0),"aes256-cbc":info("aes-256-cbc",16,32,0,0,0,0),"rijndael-cbc@lysator.liu.se":info("aes-256-cbc",16,32,0,0,0,0),"3des-cbc":info("des-ede3-cbc",8,24,0,0,0,0),"blowfish-cbc":info("bf-cbc",8,16,0,0,0,0),"idea-cbc":info("idea-cbc",8,16,0,0,0,0),"cast128-cbc":info("cast-cbc",8,16,0,0,0,0),"aes128-ctr":info("aes-128-ctr",16,16,16,0,0,k),"aes192-ctr":info("aes-192-ctr",16,24,16,0,0,k),"aes256-ctr":info("aes-256-ctr",16,32,16,0,0,k),"3des-ctr":info("des-ede3",8,24,8,0,0,k),"blowfish-ctr":info("bf-ecb",8,16,8,0,0,k),"cast128-ctr":info("cast5-ecb",8,16,8,0,0,k),arcfour:info("rc4",8,16,0,0,1536,k),arcfour128:info("rc4",8,16,0,0,1536,k),arcfour256:info("rc4",8,32,0,0,1536,k),arcfour512:info("rc4",8,64,0,0,1536,k)}})();const N=(()=>{function info(e,t,n,i){return{sslName:e,len:t,actualLen:n,isETM:i}}return{"hmac-md5":info("md5",16,16,false),"hmac-md5-96":info("md5",16,12,false),"hmac-ripemd160":info("ripemd160",20,20,false),"hmac-sha1":info("sha1",20,20,false),"hmac-sha1-etm@openssh.com":info("sha1",20,20,true),"hmac-sha1-96":info("sha1",20,12,false),"hmac-sha2-256":info("sha256",32,32,false),"hmac-sha2-256-etm@openssh.com":info("sha256",32,32,true),"hmac-sha2-256-96":info("sha256",32,12,false),"hmac-sha2-512":info("sha512",64,64,false),"hmac-sha2-512-etm@openssh.com":info("sha512",64,64,true),"hmac-sha2-512-96":info("sha512",64,12,false)}})();class NullCipher{constructor(e,t){this.outSeqno=e;this._onWrite=t;this._dead=false}free(){this._dead=true}allocPacket(e){let t=4+1+e;let n=8-(t&8-1);if(n<4)n+=8;t+=n;const i=Buffer.allocUnsafe(t);l(i,t-4,0);i[4]=n;o(i,5+e,n);return i}encrypt(e){if(this._dead)return;this._onWrite(e);this.outSeqno=this.outSeqno+1>>>0}}const T=Buffer.alloc(32);const P=Buffer.alloc(16);let U;let Q;let L;class ChaChaPolyCipherNative{constructor(e){const t=e.outbound;this.outSeqno=t.seqno;this._onWrite=t.onWrite;this._encKeyMain=t.cipherKey.slice(0,32);this._encKeyPktLen=t.cipherKey.slice(32);this._dead=false}free(){this._dead=true}allocPacket(e){let t=4+1+e;let n=8-(t-4&8-1);if(n<4)n+=8;t+=n;const i=Buffer.allocUnsafe(t);l(i,t-4,0);i[4]=n;o(i,5+e,n);return i}encrypt(e){if(this._dead)return;P[0]=0;l(P,this.outSeqno,12);const t=i("chacha20",this._encKeyMain,P).update(T);const n=i("chacha20",this._encKeyPktLen,P).update(e.slice(0,4));this._onWrite(n);P[0]=1;const r=i("chacha20",this._encKeyMain,P).update(e.slice(4));this._onWrite(r);L(Q,n,n.length,r,r.length,t);const s=Buffer.allocUnsafe(16);s.set(new Uint8Array(U.HEAPU8.buffer,Q,16),0);this._onWrite(s);this.outSeqno=this.outSeqno+1>>>0}}class ChaChaPolyCipherBinding{constructor(e){const t=e.outbound;this.outSeqno=t.seqno;this._onWrite=t.onWrite;this._instance=new y(t.cipherKey);this._dead=false}free(){this._dead=true;this._instance.free()}allocPacket(e){let t=4+1+e;let n=8-(t-4&8-1);if(n<4)n+=8;t+=n;const i=Buffer.allocUnsafe(t+16);l(i,t-4,0);i[4]=n;o(i,5+e,n);return i}encrypt(e){if(this._dead)return;this._instance.encrypt(e,this.outSeqno);this._onWrite(e);this.outSeqno=this.outSeqno+1>>>0}}class AESGCMCipherNative{constructor(e){const t=e.outbound;this.outSeqno=t.seqno;this._onWrite=t.onWrite;this._encSSLName=t.cipherInfo.sslName;this._encKey=t.cipherKey;this._encIV=t.cipherIV;this._dead=false}free(){this._dead=true}allocPacket(e){let t=4+1+e;let n=16-(t-4&16-1);if(n<4)n+=16;t+=n;const i=Buffer.allocUnsafe(t);l(i,t-4,0);i[4]=n;o(i,5+e,n);return i}encrypt(e){if(this._dead)return;const t=i(this._encSSLName,this._encKey,this._encIV);t.setAutoPadding(false);const n=e.slice(0,4);t.setAAD(n);this._onWrite(n);const r=t.update(e.slice(4));this._onWrite(r);const s=t.final();if(s.length)this._onWrite(s);const o=t.getAuthTag();this._onWrite(o);ivIncrement(this._encIV);this.outSeqno=this.outSeqno+1>>>0}}class AESGCMCipherBinding{constructor(e){const t=e.outbound;this.outSeqno=t.seqno;this._onWrite=t.onWrite;this._instance=new S(t.cipherInfo.sslName,t.cipherKey,t.cipherIV);this._dead=false}free(){this._dead=true;this._instance.free()}allocPacket(e){let t=4+1+e;let n=16-(t-4&16-1);if(n<4)n+=16;t+=n;const i=Buffer.allocUnsafe(t+16);l(i,t-4,0);i[4]=n;o(i,5+e,n);return i}encrypt(e){if(this._dead)return;this._instance.encrypt(e);this._onWrite(e);this.outSeqno=this.outSeqno+1>>>0}}class GenericCipherNative{constructor(e){const t=e.outbound;this.outSeqno=t.seqno;this._onWrite=t.onWrite;this._encBlockLen=t.cipherInfo.blockLen;this._cipherInstance=i(t.cipherInfo.sslName,t.cipherKey,t.cipherIV);this._macSSLName=t.macInfo.sslName;this._macKey=t.macKey;this._macActualLen=t.macInfo.actualLen;this._macETM=t.macInfo.isETM;this._aadLen=this._macETM?4:0;this._dead=false;const n=t.cipherInfo.discardLen;if(n){let e=p.get(n);if(e===undefined){e=Buffer.alloc(n);p.set(n,e)}this._cipherInstance.update(e)}}free(){this._dead=true}allocPacket(e){const t=this._encBlockLen;let n=4+1+e;let i=t-(n-this._aadLen&t-1);if(i<4)i+=t;n+=i;const r=Buffer.allocUnsafe(n);l(r,n-4,0);r[4]=i;o(r,5+e,i);return r}encrypt(e){if(this._dead)return;let t;if(this._macETM){const n=new Uint8Array(e.buffer,e.byteOffset,4);const i=this._cipherInstance.update(new Uint8Array(e.buffer,e.byteOffset+4,e.length-4));this._onWrite(n);this._onWrite(i);t=s(this._macSSLName,this._macKey);l(_,this.outSeqno,0);t.update(_);t.update(n);t.update(i)}else{const n=this._cipherInstance.update(e);this._onWrite(n);t=s(this._macSSLName,this._macKey);l(_,this.outSeqno,0);t.update(_);t.update(e)}let n=t.digest();if(n.length>this._macActualLen)n=n.slice(0,this._macActualLen);this._onWrite(n);this.outSeqno=this.outSeqno+1>>>0}}class GenericCipherBinding{constructor(e){const t=e.outbound;this.outSeqno=t.seqno;this._onWrite=t.onWrite;this._encBlockLen=t.cipherInfo.blockLen;this._macLen=t.macInfo.len;this._macActualLen=t.macInfo.actualLen;this._aadLen=t.macInfo.isETM?4:0;this._instance=new m(t.cipherInfo.sslName,t.cipherKey,t.cipherIV,t.macInfo.sslName,t.macKey,t.macInfo.isETM);this._dead=false}free(){this._dead=true;this._instance.free()}allocPacket(e){const t=this._encBlockLen;let n=4+1+e;let i=t-(n-this._aadLen&t-1);if(i<4)i+=t;n+=i;const r=Buffer.allocUnsafe(n+this._macLen);l(r,n-4,0);r[4]=i;o(r,5+e,i);return r}encrypt(e){if(this._dead)return;this._instance.encrypt(e,this.outSeqno);if(this._macActualLen<this._macLen){e=new u(e.buffer,e.byteOffset,e.length-(this._macLen-this._macActualLen))}this._onWrite(e);this.outSeqno=this.outSeqno+1>>>0}}class NullDecipher{constructor(e,t){this.inSeqno=e;this._onPayload=t;this._len=0;this._lenBytes=0;this._packet=null;this._packetPos=0}free(){}decrypt(e,t,n){while(t<n){if(this._lenBytes<4){let i=Math.min(4-this._lenBytes,n-t);this._lenBytes+=i;while(i--)this._len=(this._len<<8)+e[t++];if(this._lenBytes<4)return;if(this._len>E||this._len<8||(4+this._len&7)!==0){throw new Error("Bad packet length")}if(t>=n)return}if(this._packetPos<this._len){const i=Math.min(this._len-this._packetPos,n-t);if(t!==0||i!==n){if(i===this._len){this._packet=new u(e.buffer,e.byteOffset+t,i)}else{this._packet=Buffer.allocUnsafe(this._len);this._packet.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._packetPos)}}else if(i===this._len){this._packet=e}else{if(!this._packet)this._packet=Buffer.allocUnsafe(this._len);this._packet.set(e,this._packetPos)}t+=i;this._packetPos+=i;if(this._packetPos<this._len)return}const i=!this._packet?g:new u(this._packet.buffer,this._packet.byteOffset+1,this._packet.length-this._packet[0]-1);this.inSeqno=this.inSeqno+1>>>0;this._len=0;this._lenBytes=0;this._packet=null;this._packetPos=0;{const e=this._onPayload(i);if(e!==undefined)return e===false?t:e}}}}class ChaChaPolyDecipherNative{constructor(e){const t=e.inbound;this.inSeqno=t.seqno;this._onPayload=t.onPayload;this._decKeyMain=t.decipherKey.slice(0,32);this._decKeyPktLen=t.decipherKey.slice(32);this._len=0;this._lenBuf=Buffer.alloc(4);this._lenPos=0;this._packet=null;this._pktLen=0;this._mac=Buffer.allocUnsafe(16);this._calcMac=Buffer.allocUnsafe(16);this._macPos=0}free(){}decrypt(e,t,n){while(t<n){if(this._lenPos<4){let i=Math.min(4-this._lenPos,n-t);while(i--)this._lenBuf[this._lenPos++]=e[t++];if(this._lenPos<4)return;P[0]=0;l(P,this.inSeqno,12);const s=r("chacha20",this._decKeyPktLen,P).update(this._lenBuf);this._len=h(s,0);if(this._len>E||this._len<8||(this._len&7)!==0){throw new Error("Bad packet length")}}if(this._pktLen<this._len){if(t>=n)return;const i=Math.min(this._len-this._pktLen,n-t);let r;if(t!==0||i!==n)r=new Uint8Array(e.buffer,e.byteOffset+t,i);else r=e;if(i===this._len){this._packet=r}else{if(!this._packet)this._packet=Buffer.allocUnsafe(this._len);this._packet.set(r,this._pktLen)}t+=i;this._pktLen+=i;if(this._pktLen<this._len||t>=n)return}{const i=Math.min(16-this._macPos,n-t);if(t!==0||i!==n){this._mac.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._macPos)}else{this._mac.set(e,this._macPos)}t+=i;this._macPos+=i;if(this._macPos<16)return}P[0]=0;l(P,this.inSeqno,12);const s=i("chacha20",this._decKeyMain,P).update(T);L(Q,this._lenBuf,4,this._packet,this._packet.length,s);this._calcMac.set(new Uint8Array(U.HEAPU8.buffer,Q,16),0);if(!f(this._calcMac,this._mac))throw new Error("Invalid MAC");P[0]=1;const o=r("chacha20",this._decKeyMain,P).update(this._packet);const A=new u(o.buffer,o.byteOffset+1,o.length-o[0]-1);this.inSeqno=this.inSeqno+1>>>0;this._len=0;this._lenPos=0;this._packet=null;this._pktLen=0;this._macPos=0;{const e=this._onPayload(A);if(e!==undefined)return e===false?t:e}}}}class ChaChaPolyDecipherBinding{constructor(e){const t=e.inbound;this.inSeqno=t.seqno;this._onPayload=t.onPayload;this._instance=new C(t.decipherKey);this._len=0;this._lenBuf=Buffer.alloc(4);this._lenPos=0;this._packet=null;this._pktLen=0;this._mac=Buffer.allocUnsafe(16);this._macPos=0}free(){this._instance.free()}decrypt(e,t,n){while(t<n){if(this._lenPos<4){let i=Math.min(4-this._lenPos,n-t);while(i--)this._lenBuf[this._lenPos++]=e[t++];if(this._lenPos<4)return;this._len=this._instance.decryptLen(this._lenBuf,this.inSeqno);if(this._len>E||this._len<8||(this._len&7)!==0){throw new Error("Bad packet length")}if(t>=n)return}if(this._pktLen<this._len){const i=Math.min(this._len-this._pktLen,n-t);let r;if(t!==0||i!==n)r=new Uint8Array(e.buffer,e.byteOffset+t,i);else r=e;if(i===this._len){this._packet=r}else{if(!this._packet)this._packet=Buffer.allocUnsafe(this._len);this._packet.set(r,this._pktLen)}t+=i;this._pktLen+=i;if(this._pktLen<this._len||t>=n)return}{const i=Math.min(16-this._macPos,n-t);if(t!==0||i!==n){this._mac.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._macPos)}else{this._mac.set(e,this._macPos)}t+=i;this._macPos+=i;if(this._macPos<16)return}this._instance.decrypt(this._packet,this._mac,this.inSeqno);const i=new u(this._packet.buffer,this._packet.byteOffset+1,this._packet.length-this._packet[0]-1);this.inSeqno=this.inSeqno+1>>>0;this._len=0;this._lenPos=0;this._packet=null;this._pktLen=0;this._macPos=0;{const e=this._onPayload(i);if(e!==undefined)return e===false?t:e}}}}class AESGCMDecipherNative{constructor(e){const t=e.inbound;this.inSeqno=t.seqno;this._onPayload=t.onPayload;this._decipherInstance=null;this._decipherSSLName=t.decipherInfo.sslName;this._decipherKey=t.decipherKey;this._decipherIV=t.decipherIV;this._len=0;this._lenBytes=0;this._packet=null;this._packetPos=0;this._pktLen=0;this._tag=Buffer.allocUnsafe(16);this._tagPos=0}free(){}decrypt(e,t,n){while(t<n){if(this._lenBytes<4){let i=Math.min(4-this._lenBytes,n-t);this._lenBytes+=i;while(i--)this._len=(this._len<<8)+e[t++];if(this._lenBytes<4)return;if(this._len+20>E||this._len<16||(this._len&15)!==0){throw new Error("Bad packet length")}this._decipherInstance=r(this._decipherSSLName,this._decipherKey,this._decipherIV);this._decipherInstance.setAutoPadding(false);this._decipherInstance.setAAD(O(this._len))}if(this._pktLen<this._len){if(t>=n)return;const i=Math.min(this._len-this._pktLen,n-t);let r;if(t!==0||i!==n){r=this._decipherInstance.update(new Uint8Array(e.buffer,e.byteOffset+t,i))}else{r=this._decipherInstance.update(e)}if(r.length){if(i===this._len){this._packet=r}else{if(!this._packet)this._packet=Buffer.allocUnsafe(this._len);this._packet.set(r,this._packetPos)}this._packetPos+=r.length}t+=i;this._pktLen+=i;if(this._pktLen<this._len||t>=n)return}{const i=Math.min(16-this._tagPos,n-t);if(t!==0||i!==n){this._tag.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._tagPos)}else{this._tag.set(e,this._tagPos)}t+=i;this._tagPos+=i;if(this._tagPos<16)return}{this._decipherInstance.setAuthTag(this._tag);const e=this._decipherInstance.final();if(e.length){if(this._packet)this._packet.set(e,this._packetPos);else this._packet=e}}const i=!this._packet?g:new u(this._packet.buffer,this._packet.byteOffset+1,this._packet.length-this._packet[0]-1);this.inSeqno=this.inSeqno+1>>>0;ivIncrement(this._decipherIV);this._len=0;this._lenBytes=0;this._packet=null;this._packetPos=0;this._pktLen=0;this._tagPos=0;{const e=this._onPayload(i);if(e!==undefined)return e===false?t:e}}}}class AESGCMDecipherBinding{constructor(e){const t=e.inbound;this.inSeqno=t.seqno;this._onPayload=t.onPayload;this._instance=new w(t.decipherInfo.sslName,t.decipherKey,t.decipherIV);this._len=0;this._lenBytes=0;this._packet=null;this._pktLen=0;this._tag=Buffer.allocUnsafe(16);this._tagPos=0}free(){}decrypt(e,t,n){while(t<n){if(this._lenBytes<4){let i=Math.min(4-this._lenBytes,n-t);this._lenBytes+=i;while(i--)this._len=(this._len<<8)+e[t++];if(this._lenBytes<4)return;if(this._len+20>E||this._len<16||(this._len&15)!==0){throw new Error(`Bad packet length: ${this._len}`)}}if(this._pktLen<this._len){if(t>=n)return;const i=Math.min(this._len-this._pktLen,n-t);let r;if(t!==0||i!==n)r=new Uint8Array(e.buffer,e.byteOffset+t,i);else r=e;if(i===this._len){this._packet=r}else{if(!this._packet)this._packet=Buffer.allocUnsafe(this._len);this._packet.set(r,this._pktLen)}t+=i;this._pktLen+=i;if(this._pktLen<this._len||t>=n)return}{const i=Math.min(16-this._tagPos,n-t);if(t!==0||i!==n){this._tag.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._tagPos)}else{this._tag.set(e,this._tagPos)}t+=i;this._tagPos+=i;if(this._tagPos<16)return}this._instance.decrypt(this._packet,this._len,this._tag);const i=new u(this._packet.buffer,this._packet.byteOffset+1,this._packet.length-this._packet[0]-1);this.inSeqno=this.inSeqno+1>>>0;this._len=0;this._lenBytes=0;this._packet=null;this._pktLen=0;this._tagPos=0;{const e=this._onPayload(i);if(e!==undefined)return e===false?t:e}}}}class GenericDecipherNative{constructor(e){const t=e.inbound;this.inSeqno=t.seqno;this._onPayload=t.onPayload;this._decipherInstance=r(t.decipherInfo.sslName,t.decipherKey,t.decipherIV);this._decipherInstance.setAutoPadding(false);this._block=Buffer.allocUnsafe(t.macInfo.isETM?4:t.decipherInfo.blockLen);this._blockSize=t.decipherInfo.blockLen;this._blockPos=0;this._len=0;this._packet=null;this._packetPos=0;this._pktLen=0;this._mac=Buffer.allocUnsafe(t.macInfo.actualLen);this._macPos=0;this._macSSLName=t.macInfo.sslName;this._macKey=t.macKey;this._macActualLen=t.macInfo.actualLen;this._macETM=t.macInfo.isETM;this._macInstance=null;const n=t.decipherInfo.discardLen;if(n){let e=p.get(n);if(e===undefined){e=Buffer.alloc(n);p.set(n,e)}this._decipherInstance.update(e)}}free(){}decrypt(e,t,n){while(t<n){if(this._blockPos<this._block.length){const i=Math.min(this._block.length-this._blockPos,n-t);if(t!==0||i!==n||i<e.length){this._block.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._blockPos)}else{this._block.set(e,this._blockPos)}t+=i;this._blockPos+=i;if(this._blockPos<this._block.length)return;let r;let o;if(this._macETM){this._len=o=h(this._block,0)}else{r=this._decipherInstance.update(this._block);this._len=h(r,0);o=4+this._len-this._blockSize}if(this._len>E||this._len<5||(o&this._blockSize-1)!==0){throw new Error("Bad packet length")}this._macInstance=s(this._macSSLName,this._macKey);l(_,this.inSeqno,0);this._macInstance.update(_);if(this._macETM){this._macInstance.update(this._block)}else{this._macInstance.update(new Uint8Array(r.buffer,r.byteOffset,4));this._pktLen=r.length-4;this._packetPos=this._pktLen;this._packet=Buffer.allocUnsafe(this._len);this._packet.set(new Uint8Array(r.buffer,r.byteOffset+4,this._packetPos),0)}if(t>=n)return}if(this._pktLen<this._len){const i=Math.min(this._len-this._pktLen,n-t);let r;if(t!==0||i!==n)r=new Uint8Array(e.buffer,e.byteOffset+t,i);else r=e;if(this._macETM)this._macInstance.update(r);const s=this._decipherInstance.update(r);if(s.length){if(i===this._len){this._packet=s}else{if(!this._packet)this._packet=Buffer.allocUnsafe(this._len);this._packet.set(s,this._packetPos)}this._packetPos+=s.length}t+=i;this._pktLen+=i;if(this._pktLen<this._len||t>=n)return}{const i=Math.min(this._macActualLen-this._macPos,n-t);if(t!==0||i!==n){this._mac.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._macPos)}else{this._mac.set(e,this._macPos)}t+=i;this._macPos+=i;if(this._macPos<this._macActualLen)return}if(!this._macETM)this._macInstance.update(this._packet);let i=this._macInstance.digest();if(this._macActualLen<i.length){i=new Uint8Array(i.buffer,i.byteOffset,this._macActualLen)}if(!timingSafeEquals(i,this._mac))throw new Error("Invalid MAC");const r=new u(this._packet.buffer,this._packet.byteOffset+1,this._packet.length-this._packet[0]-1);this.inSeqno=this.inSeqno+1>>>0;this._blockPos=0;this._len=0;this._packet=null;this._packetPos=0;this._pktLen=0;this._macPos=0;this._macInstance=null;{const e=this._onPayload(r);if(e!==undefined)return e===false?t:e}}}}class GenericDecipherBinding{constructor(e){const t=e.inbound;this.inSeqno=t.seqno;this._onPayload=t.onPayload;this._instance=new B(t.decipherInfo.sslName,t.decipherKey,t.decipherIV,t.macInfo.sslName,t.macKey,t.macInfo.isETM,t.macInfo.actualLen);this._block=Buffer.allocUnsafe(t.macInfo.isETM||t.decipherInfo.stream?4:t.decipherInfo.blockLen);this._blockPos=0;this._len=0;this._packet=null;this._pktLen=0;this._mac=Buffer.allocUnsafe(t.macInfo.actualLen);this._macPos=0;this._macActualLen=t.macInfo.actualLen;this._macETM=t.macInfo.isETM}free(){this._instance.free()}decrypt(e,t,n){while(t<n){if(this._blockPos<this._block.length){const i=Math.min(this._block.length-this._blockPos,n-t);if(t!==0||i!==n||i<e.length){this._block.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._blockPos)}else{this._block.set(e,this._blockPos)}t+=i;this._blockPos+=i;if(this._blockPos<this._block.length)return;let r;if(this._macETM){this._len=r=h(this._block,0)}else{this._instance.decryptBlock(this._block);this._len=h(this._block,0);r=4+this._len-this._block.length}if(this._len>E||this._len<5||(r&this._block.length-1)!==0){throw new Error("Bad packet length")}if(!this._macETM){this._pktLen=this._block.length-4;if(this._pktLen){this._packet=Buffer.allocUnsafe(this._len);this._packet.set(new Uint8Array(this._block.buffer,this._block.byteOffset+4,this._pktLen),0)}}if(t>=n)return}if(this._pktLen<this._len){const i=Math.min(this._len-this._pktLen,n-t);let r;if(t!==0||i!==n)r=new Uint8Array(e.buffer,e.byteOffset+t,i);else r=e;if(i===this._len){this._packet=r}else{if(!this._packet)this._packet=Buffer.allocUnsafe(this._len);this._packet.set(r,this._pktLen)}t+=i;this._pktLen+=i;if(this._pktLen<this._len||t>=n)return}{const i=Math.min(this._macActualLen-this._macPos,n-t);if(t!==0||i!==n){this._mac.set(new Uint8Array(e.buffer,e.byteOffset+t,i),this._macPos)}else{this._mac.set(e,this._macPos)}t+=i;this._macPos+=i;if(this._macPos<this._macActualLen)return}this._instance.decrypt(this._packet,this.inSeqno,this._block,this._mac);const i=new u(this._packet.buffer,this._packet.byteOffset+1,this._packet.length-this._packet[0]-1);this.inSeqno=this.inSeqno+1>>>0;this._blockPos=0;this._len=0;this._packet=null;this._pktLen=0;this._macPos=0;this._macInstance=null;{const e=this._onPayload(i);if(e!==undefined)return e===false?t:e}}}}function ivIncrement(e){++e[11]>>>8&&++e[10]>>>8&&++e[9]>>>8&&++e[8]>>>8&&++e[7]>>>8&&++e[6]>>>8&&++e[5]>>>8&&++e[4]>>>8}const O=(()=>{const e=Buffer.alloc(4);return t=>{e[0]=t>>>24;e[1]=t>>>16;e[2]=t>>>8;e[3]=t;return e}})();function timingSafeEquals(e,t){if(e.length!==t.length){f(e,e);return false}return f(e,t)}function createCipher(e){if(typeof e!=="object"||e===null)throw new Error("Invalid config");if(typeof e.outbound!=="object"||e.outbound===null)throw new Error("Invalid outbound");const t=e.outbound;if(typeof t.onWrite!=="function")throw new Error("Invalid outbound.onWrite");if(typeof t.cipherInfo!=="object"||t.cipherInfo===null)throw new Error("Invalid outbound.cipherInfo");if(!Buffer.isBuffer(t.cipherKey)||t.cipherKey.length!==t.cipherInfo.keyLen){throw new Error("Invalid outbound.cipherKey")}if(t.cipherInfo.ivLen&&(!Buffer.isBuffer(t.cipherIV)||t.cipherIV.length!==t.cipherInfo.ivLen)){throw new Error("Invalid outbound.cipherIV")}if(typeof t.seqno!=="number"||t.seqno<0||t.seqno>A){throw new Error("Invalid outbound.seqno")}const n=!!t.forceNative;switch(t.cipherInfo.sslName){case"aes-128-gcm":case"aes-256-gcm":return S&&!n?new AESGCMCipherBinding(e):new AESGCMCipherNative(e);case"chacha20":return y&&!n?new ChaChaPolyCipherBinding(e):new ChaChaPolyCipherNative(e);default:{if(typeof t.macInfo!=="object"||t.macInfo===null)throw new Error("Invalid outbound.macInfo");if(!Buffer.isBuffer(t.macKey)||t.macKey.length!==t.macInfo.len){throw new Error("Invalid outbound.macKey")}return m&&!n?new GenericCipherBinding(e):new GenericCipherNative(e)}}}function createDecipher(e){if(typeof e!=="object"||e===null)throw new Error("Invalid config");if(typeof e.inbound!=="object"||e.inbound===null)throw new Error("Invalid inbound");const t=e.inbound;if(typeof t.onPayload!=="function")throw new Error("Invalid inbound.onPayload");if(typeof t.decipherInfo!=="object"||t.decipherInfo===null){throw new Error("Invalid inbound.decipherInfo")}if(!Buffer.isBuffer(t.decipherKey)||t.decipherKey.length!==t.decipherInfo.keyLen){throw new Error("Invalid inbound.decipherKey")}if(t.decipherInfo.ivLen&&(!Buffer.isBuffer(t.decipherIV)||t.decipherIV.length!==t.decipherInfo.ivLen)){throw new Error("Invalid inbound.decipherIV")}if(typeof t.seqno!=="number"||t.seqno<0||t.seqno>A){throw new Error("Invalid inbound.seqno")}const n=!!t.forceNative;switch(t.decipherInfo.sslName){case"aes-128-gcm":case"aes-256-gcm":return w&&!n?new AESGCMDecipherBinding(e):new AESGCMDecipherNative(e);case"chacha20":return C&&!n?new ChaChaPolyDecipherBinding(e):new ChaChaPolyDecipherNative(e);default:{if(typeof t.macInfo!=="object"||t.macInfo===null)throw new Error("Invalid inbound.macInfo");if(!Buffer.isBuffer(t.macKey)||t.macKey.length!==t.macInfo.len){throw new Error("Invalid inbound.macKey")}return B&&!n?new GenericDecipherBinding(e):new GenericDecipherNative(e)}}}e.exports={CIPHER_INFO:R,MAC_INFO:N,bindingAvailable:!!b,init:(()=>new Promise((async(e,t)=>{try{U=await n(525)();Q=U._malloc(16);L=U.cwrap("poly1305_auth",null,["number","array","number","array","number","array"])}catch(e){return t(e)}e()})))(),NullCipher:NullCipher,createCipher:createCipher,NullDecipher:NullDecipher,createDecipher:createDecipher}},958:(e,t,n)=>{const i=new Array(256);[n(352).HANDLERS,n(594)].forEach((e=>{for(let[t,n]of Object.entries(e)){t=+t;if(isFinite(t)&&t>=0&&t<i.length)i[t]=n}}));e.exports=i},594:(e,t,n)=>{const{bufferSlice:i,bufferParser:r,doFatalError:s,sigSSHToASN1:o,writeUInt32BE:f}=n(223);const{CHANNEL_OPEN_FAILURE:h,COMPAT:l,MESSAGE:u,TERMINAL_MODE:A}=n(434);const{parseKey:g}=n(887);const _=Array.from(Object.entries(A)).reduce(((e,[t,n])=>({...e,[t]:n})),{});e.exports={[u.DISCONNECT]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();const i=r.readString(true);const o=r.readString();r.clear();if(o===undefined){return s(e,"Inbound: Malformed DISCONNECT packet")}e._debug&&e._debug(`Inbound: Received DISCONNECT (${n}, "${i}")`);const f=e._handlers.DISCONNECT;f&&f(e,n,i)},[u.IGNORE]:(e,t)=>{e._debug&&e._debug("Inbound: Received IGNORE")},[u.UNIMPLEMENTED]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();r.clear();if(n===undefined){return s(e,"Inbound: Malformed UNIMPLEMENTED packet")}e._debug&&e._debug(`Inbound: Received UNIMPLEMENTED (seqno ${n})`)},[u.DEBUG]:(e,t)=>{r.init(t,1);const n=r.readBool();const i=r.readString(true);const o=r.readString();r.clear();if(o===undefined){return s(e,"Inbound: Malformed DEBUG packet")}e._debug&&e._debug("Inbound: Received DEBUG");const f=e._handlers.DEBUG;f&&f(e,n,i)},[u.SERVICE_REQUEST]:(e,t)=>{r.init(t,1);const n=r.readString(true);r.clear();if(n===undefined){return s(e,"Inbound: Malformed SERVICE_REQUEST packet")}e._debug&&e._debug(`Inbound: Received SERVICE_REQUEST (${n})`);const i=e._handlers.SERVICE_REQUEST;i&&i(e,n)},[u.SERVICE_ACCEPT]:(e,t)=>{r.init(t,1);const n=r.readString(true);r.clear();if(n===undefined){return s(e,"Inbound: Malformed SERVICE_ACCEPT packet")}e._debug&&e._debug(`Inbound: Received SERVICE_ACCEPT (${n})`);const i=e._handlers.SERVICE_ACCEPT;i&&i(e,n)},[u.USERAUTH_REQUEST]:(e,t)=>{r.init(t,1);const n=r.readString(true);const h=r.readString(true);const l=r.readString(true);let u;let A;switch(l){case"none":u=null;break;case"password":{const e=r.readBool();if(e!==undefined){u=r.readString(true);if(u!==undefined&&e){const e=r.readString(true);if(e!==undefined)u={oldPassword:u,newPassword:e};else u=undefined}}break}case"publickey":{const n=r.readBool();if(n!==undefined){const s=r.readString(true);const h=r.readString();if(n){const n=r.pos();let l=r.readString();if(l!==undefined){if(l.length>4+s.length+4&&l.utf8Slice(4,4+s.length)===s){l=i(l,4+s.length+4)}l=o(l,s);if(l){const i=e._kex.sessionID;const r=Buffer.allocUnsafe(4+i.length+n);f(r,i.length,0);r.set(i,4);r.set(new Uint8Array(t.buffer,t.byteOffset,n),4+i.length);u={keyAlgo:s,key:h,signature:l,blob:r}}}}else{u={keyAlgo:s,key:h};A="publickey -- check"}}break}case"hostbased":{const n=r.readString(true);const s=r.readString();const h=r.readString(true);const l=r.readString(true);const A=r.pos();let g=r.readString();if(g!==undefined){if(g.length>4+n.length+4&&g.utf8Slice(4,4+n.length)===n){g=i(g,4+n.length+4)}g=o(g,n);if(g!==undefined){const i=e._kex.sessionID;const r=Buffer.allocUnsafe(4+i.length+A);f(r,i.length,0);r.set(i,4);r.set(new Uint8Array(t.buffer,t.byteOffset,A),4+i.length);u={keyAlgo:n,key:s,signature:g,blob:r,localHostname:h,localUsername:l}}}break}case"keyboard-interactive":r.skipString();u=r.readList();break;default:if(l!==undefined)u=r.readRaw()}r.clear();if(u===undefined){return s(e,"Inbound: Malformed USERAUTH_REQUEST packet")}if(A===undefined)A=l;e._authsQueue.push(l);e._debug&&e._debug(`Inbound: Received USERAUTH_REQUEST (${A})`);const g=e._handlers.USERAUTH_REQUEST;g&&g(e,n,h,l,u)},[u.USERAUTH_FAILURE]:(e,t)=>{r.init(t,1);const n=r.readList();const i=r.readBool();r.clear();if(i===undefined){return s(e,"Inbound: Malformed USERAUTH_FAILURE packet")}e._debug&&e._debug(`Inbound: Received USERAUTH_FAILURE (${n})`);e._authsQueue.shift();const o=e._handlers.USERAUTH_FAILURE;o&&o(e,n,i)},[u.USERAUTH_SUCCESS]:(e,t)=>{e._debug&&e._debug("Inbound: Received USERAUTH_SUCCESS");e._authsQueue.shift();const n=e._handlers.USERAUTH_SUCCESS;n&&n(e)},[u.USERAUTH_BANNER]:(e,t)=>{r.init(t,1);const n=r.readString(true);const i=r.readString();r.clear();if(i===undefined){return s(e,"Inbound: Malformed USERAUTH_BANNER packet")}e._debug&&e._debug("Inbound: Received USERAUTH_BANNER");const o=e._handlers.USERAUTH_BANNER;o&&o(e,n)},60:(e,t)=>{if(!e._authsQueue.length){e._debug&&e._debug("Inbound: Received payload type 60 without auth");return}switch(e._authsQueue[0]){case"password":{r.init(t,1);const n=r.readString(true);const i=r.readString();r.clear();if(i===undefined){return s(e,"Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet")}e._debug&&e._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");const o=e._handlers.USERAUTH_PASSWD_CHANGEREQ;o&&o(e,n);break}case"publickey":{r.init(t,1);const n=r.readString(true);const i=r.readString();r.clear();if(i===undefined){return s(e,"Inbound: Malformed USERAUTH_PK_OK packet")}e._debug&&e._debug("Inbound: Received USERAUTH_PK_OK");e._authsQueue.shift();const o=e._handlers.USERAUTH_PK_OK;o&&o(e,n,i);break}case"keyboard-interactive":{r.init(t,1);const n=r.readString(true);const i=r.readString(true);r.readString();const o=r.readUInt32BE();let f;if(o!==undefined){f=new Array(o);let e;for(e=0;e<o;++e){const t=r.readString(true);const n=r.readBool();if(n===undefined)break;f[e]={prompt:t,echo:n}}if(e!==o)f=undefined}r.clear();if(f===undefined){return s(e,"Inbound: Malformed USERAUTH_INFO_REQUEST packet")}e._debug&&e._debug("Inbound: Received USERAUTH_INFO_REQUEST");const h=e._handlers.USERAUTH_INFO_REQUEST;h&&h(e,n,i,f);break}default:e._debug&&e._debug("Inbound: Received unexpected payload type 60")}},61:(e,t)=>{if(!e._authsQueue.length){e._debug&&e._debug("Inbound: Received payload type 61 without auth");return}if(e._authsQueue[0]!=="keyboard-interactive"){return s(e,"Inbound: Received unexpected payload type 61")}r.init(t,1);const n=r.readUInt32BE();let i;if(n!==undefined){i=new Array(n);let e;for(e=0;e<n;++e){const t=r.readString(true);if(t===undefined)break;i[e]=t}if(e!==n)i=undefined}r.clear();if(i===undefined){return s(e,"Inbound: Malformed USERAUTH_INFO_RESPONSE packet")}e._debug&&e._debug("Inbound: Received USERAUTH_INFO_RESPONSE");const o=e._handlers.USERAUTH_INFO_RESPONSE;o&&o(e,i)},[u.GLOBAL_REQUEST]:(e,t)=>{r.init(t,1);const n=r.readString(true);const i=r.readBool();let o;if(i!==undefined){switch(n){case"tcpip-forward":case"cancel-tcpip-forward":{const e=r.readString(true);const t=r.readUInt32BE();if(t!==undefined)o={bindAddr:e,bindPort:t};break}case"streamlocal-forward@openssh.com":case"cancel-streamlocal-forward@openssh.com":{const e=r.readString(true);if(e!==undefined)o={socketPath:e};break}case"no-more-sessions@openssh.com":o=null;break;case"hostkeys-00@openssh.com":{o=[];while(r.avail()>0){const e=r.readString();if(e===undefined){o=undefined;break}const t=g(e);if(!(t instanceof Error))o.push(t)}break}default:o=r.readRaw()}}r.clear();if(o===undefined){return s(e,"Inbound: Malformed GLOBAL_REQUEST packet")}e._debug&&e._debug(`Inbound: GLOBAL_REQUEST (${n})`);const f=e._handlers.GLOBAL_REQUEST;if(f)f(e,n,i,o);else e.requestFailure()},[u.REQUEST_SUCCESS]:(e,t)=>{const n=t.length>1?i(t,1):null;e._debug&&e._debug("Inbound: REQUEST_SUCCESS");const r=e._handlers.REQUEST_SUCCESS;r&&r(e,n)},[u.REQUEST_FAILURE]:(e,t)=>{e._debug&&e._debug("Inbound: Received REQUEST_FAILURE");const n=e._handlers.REQUEST_FAILURE;n&&n(e)},[u.CHANNEL_OPEN]:(e,t)=>{r.init(t,1);const n=r.readString(true);const i=r.readUInt32BE();const o=r.readUInt32BE();const f=r.readUInt32BE();let l;switch(n){case"forwarded-tcpip":case"direct-tcpip":{const e=r.readString(true);const t=r.readUInt32BE();const s=r.readString(true);const h=r.readUInt32BE();if(h!==undefined){l={type:n,sender:i,window:o,packetSize:f,data:{destIP:e,destPort:t,srcIP:s,srcPort:h}}}break}case"forwarded-streamlocal@openssh.com":case"direct-streamlocal@openssh.com":{const e=r.readString(true);if(e!==undefined){l={type:n,sender:i,window:o,packetSize:f,data:{socketPath:e}}}break}case"x11":{const e=r.readString(true);const t=r.readUInt32BE();if(t!==undefined){l={type:n,sender:i,window:o,packetSize:f,data:{srcIP:e,srcPort:t}}}break}default:l={type:n,sender:i,window:o,packetSize:f,data:{}}}r.clear();if(l===undefined){return s(e,"Inbound: Malformed CHANNEL_OPEN packet")}e._debug&&e._debug(`Inbound: CHANNEL_OPEN (s:${i}, ${n})`);const u=e._handlers.CHANNEL_OPEN;if(u){u(e,l)}else{e.channelOpenFail(l.sender,h.ADMINISTRATIVELY_PROHIBITED,"","")}},[u.CHANNEL_OPEN_CONFIRMATION]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();const i=r.readUInt32BE();const o=r.readUInt32BE();const f=r.readUInt32BE();const h=r.avail()?r.readRaw():undefined;r.clear();if(f===undefined){return s(e,"Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet")}e._debug&&e._debug(`Inbound: CHANNEL_OPEN_CONFIRMATION (r:${n}, s:${i})`);const l=e._handlers.CHANNEL_OPEN_CONFIRMATION;if(l)l(e,{recipient:n,sender:i,window:o,packetSize:f,data:h})},[u.CHANNEL_OPEN_FAILURE]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();const i=r.readUInt32BE();const o=r.readString(true);const f=r.readString();r.clear();if(f===undefined){return s(e,"Inbound: Malformed CHANNEL_OPEN_FAILURE packet")}e._debug&&e._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${n})`);const h=e._handlers.CHANNEL_OPEN_FAILURE;h&&h(e,n,i,o)},[u.CHANNEL_WINDOW_ADJUST]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();const i=r.readUInt32BE();r.clear();if(i===undefined){return s(e,"Inbound: Malformed CHANNEL_WINDOW_ADJUST packet")}e._debug&&e._debug(`Inbound: CHANNEL_WINDOW_ADJUST (r:${n}, ${i})`);const o=e._handlers.CHANNEL_WINDOW_ADJUST;o&&o(e,n,i)},[u.CHANNEL_DATA]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();const i=r.readString();r.clear();if(i===undefined){return s(e,"Inbound: Malformed CHANNEL_DATA packet")}e._debug&&e._debug(`Inbound: CHANNEL_DATA (r:${n}, ${i.length})`);const o=e._handlers.CHANNEL_DATA;o&&o(e,n,i)},[u.CHANNEL_EXTENDED_DATA]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();const i=r.readUInt32BE();const o=r.readString();r.clear();if(o===undefined){return s(e,"Inbound: Malformed CHANNEL_EXTENDED_DATA packet")}e._debug&&e._debug(`Inbound: CHANNEL_EXTENDED_DATA (r:${n}, ${o.length})`);const f=e._handlers.CHANNEL_EXTENDED_DATA;f&&f(e,n,o,i)},[u.CHANNEL_EOF]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();r.clear();if(n===undefined){return s(e,"Inbound: Malformed CHANNEL_EOF packet")}e._debug&&e._debug(`Inbound: CHANNEL_EOF (r:${n})`);const i=e._handlers.CHANNEL_EOF;i&&i(e,n)},[u.CHANNEL_CLOSE]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();r.clear();if(n===undefined){return s(e,"Inbound: Malformed CHANNEL_CLOSE packet")}e._debug&&e._debug(`Inbound: CHANNEL_CLOSE (r:${n})`);const i=e._handlers.CHANNEL_CLOSE;i&&i(e,n)},[u.CHANNEL_REQUEST]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();const i=r.readString(true);const o=r.readBool();let f;if(o!==undefined){switch(i){case"exit-status":f=r.readUInt32BE();e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i}: ${f})`);break;case"exit-signal":{let t;let s;if(e._compatFlags&l.OLD_EXIT){const e=r.readUInt32BE();switch(e){case 1:t="HUP";break;case 2:t="INT";break;case 3:t="QUIT";break;case 6:t="ABRT";break;case 9:t="KILL";break;case 14:t="ALRM";break;case 15:t="TERM";break;default:if(e!==undefined){t=`UNKNOWN (${e})`}}s=false}else{t=r.readString(true);s=r.readBool();if(s===undefined)t=undefined}const o=r.readString(true);if(r.skipString()!==undefined)f={signal:t,coreDumped:s,errorMessage:o};e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i}: ${t})`);break}case"pty-req":{const t=r.readString(true);const s=r.readUInt32BE();const o=r.readUInt32BE();const h=r.readUInt32BE();const l=r.readUInt32BE();const u=r.readString();if(u!==undefined){r.init(u,1);let e={};while(r.avail()){const t=r.readByte();if(t===A.TTY_OP_END)break;const n=_[t];const i=r.readUInt32BE();if(t===undefined||n===undefined||i===undefined){e=undefined;break}e[n]=i}if(e!==undefined)f={term:t,cols:s,rows:o,width:h,height:l,modes:e}}e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i})`);break}case"window-change":{const t=r.readUInt32BE();const s=r.readUInt32BE();const o=r.readUInt32BE();const h=r.readUInt32BE();if(h!==undefined)f={cols:t,rows:s,width:o,height:h};e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i})`);break}case"x11-req":{const t=r.readBool();const s=r.readString(true);const o=r.readString();const h=r.readUInt32BE();if(h!==undefined)f={single:t,protocol:s,cookie:o,screen:h};e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i})`);break}case"env":{const t=r.readString(true);const s=r.readString(true);if(s!==undefined)f={name:t,value:s};if(e._debug){e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i}: `+`${t}=${s})`)}break}case"shell":f=null;e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i})`);break;case"exec":f=r.readString(true);e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i}: ${f})`);break;case"subsystem":f=r.readString(true);e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i}: ${f})`);break;case"signal":f=r.readString(true);e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i}: ${f})`);break;case"xon-xoff":f=r.readBool();e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i}: ${f})`);break;case"auth-agent-req@openssh.com":f=null;e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i})`);break;default:f=r.avail()?r.readRaw():null;e._debug&&e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${i})`)}}r.clear();if(f===undefined){return s(e,"Inbound: Malformed CHANNEL_REQUEST packet")}const h=e._handlers.CHANNEL_REQUEST;h&&h(e,n,i,o,f)},[u.CHANNEL_SUCCESS]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();r.clear();if(n===undefined){return s(e,"Inbound: Malformed CHANNEL_SUCCESS packet")}e._debug&&e._debug(`Inbound: CHANNEL_SUCCESS (r:${n})`);const i=e._handlers.CHANNEL_SUCCESS;i&&i(e,n)},[u.CHANNEL_FAILURE]:(e,t)=>{r.init(t,1);const n=r.readUInt32BE();r.clear();if(n===undefined){return s(e,"Inbound: Malformed CHANNEL_FAILURE packet")}e._debug&&e._debug(`Inbound: CHANNEL_FAILURE (r:${n})`);const i=e._handlers.CHANNEL_FAILURE;i&&i(e,n)}}},352:(e,t,n)=>{const{createDiffieHellman:i,createDiffieHellmanGroup:r,createECDH:s,createHash:o,createPublicKey:f,diffieHellman:h,generateKeyPairSync:l,randomFillSync:u}=n(113);const{Ber:A}=n(461);const{COMPAT:g,curve25519Supported:_,DEFAULT_KEX:p,DEFAULT_SERVER_HOST_KEY:E,DEFAULT_CIPHER:b,DEFAULT_MAC:S,DEFAULT_COMPRESSION:y,DISCONNECT_REASON:m,MESSAGE:w}=n(434);const{CIPHER_INFO:C,createCipher:B,createDecipher:k,MAC_INFO:R}=n(298);const{parseDERKey:N}=n(887);const{bufferFill:T,bufferParser:P,convertSignature:U,doFatalError:Q,FastBuffer:L,sigSSHToASN1:O,writeUInt32BE:D}=n(223);const{PacketReader:v,PacketWriter:H,ZlibPacketReader:F,ZlibPacketWriter:W}=n(983);let x;const M=2048;const q=8192;const G=Buffer.alloc(0);function kexinit(e){let t;if(e._compatFlags&g.BAD_DHGEX){const n=e._offer.lists.kex;let i=n.array;let r=false;for(let e=0;e<i.length;++e){if(i[e].indexOf("group-exchange")!==-1){if(!r){r=true;i=i.slice()}i.splice(e--,1)}}if(r){let r=1+16+e._offer.totalSize+1+4;const s=Buffer.from(i.join(","));r-=n.buffer.length-s.length;const o=e._offer.lists.all;const f=new Uint8Array(o.buffer,o.byteOffset+4+n.buffer.length,o.length-(4+n.buffer.length));t=Buffer.allocUnsafe(r);D(t,s.length,0);t.set(s,4);t.set(f,4+s.length)}}if(t===undefined){t=Buffer.allocUnsafe(1+16+e._offer.totalSize+1+4);e._offer.copyAllTo(t,17)}e._debug&&e._debug("Outbound: Sending KEXINIT");t[0]=w.KEXINIT;u(t,1,16);T(t,0,t.length-5);e._kexinit=t;e._packetRW.write.allocStart=0;{const n=e._packetRW.write.allocStartKEX;const i=e._packetRW.write.alloc(t.length,true);i.set(t,n);e._cipher.encrypt(e._packetRW.write.finalize(i,true))}}function handleKexInit(e,t){const n={kex:undefined,serverHostKey:undefined,cs:{cipher:undefined,mac:undefined,compress:undefined,lang:undefined},sc:{cipher:undefined,mac:undefined,compress:undefined,lang:undefined}};P.init(t,17);if((n.kex=P.readList())===undefined||(n.serverHostKey=P.readList())===undefined||(n.cs.cipher=P.readList())===undefined||(n.sc.cipher=P.readList())===undefined||(n.cs.mac=P.readList())===undefined||(n.sc.mac=P.readList())===undefined||(n.cs.compress=P.readList())===undefined||(n.sc.compress=P.readList())===undefined||(n.cs.lang=P.readList())===undefined||(n.sc.lang=P.readList())===undefined){P.clear();return Q(e,"Received malformed KEXINIT","handshake",m.KEY_EXCHANGE_FAILED)}const i=P.pos();const r=i<t.length&&t[i]===1;P.clear();const s=e._offer;const o=n;let f=s.lists.kex.array;if(e._compatFlags&g.BAD_DHGEX){let e=false;for(let t=0;t<f.length;++t){if(f[t].indexOf("group-exchange")!==-1){if(!e){e=true;f=f.slice()}f.splice(t--,1)}}}let h;let l;let u;const A=e._debug;A&&A("Inbound: Handshake in progress");A&&A(`Handshake: (local) KEX method: ${f}`);A&&A(`Handshake: (remote) KEX method: ${o.kex}`);if(e._server){l=f;h=o.kex}else{l=o.kex;h=f}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching key exchange algorithm");return Q(e,"Handshake failed: no matching key exchange algorithm","handshake",m.KEY_EXCHANGE_FAILED)}n.kex=h[u];A&&A(`Handshake: KEX algorithm: ${h[u]}`);if(r&&(!o.kex.length||h[u]!==o.kex[0])){e._skipNextInboundPacket=true}const _=s.lists.serverHostKey.array;A&&A(`Handshake: (local) Host key format: ${_}`);A&&A(`Handshake: (remote) Host key format: ${o.serverHostKey}`);if(e._server){l=_;h=o.serverHostKey}else{l=o.serverHostKey;h=_}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching host key format");return Q(e,"Handshake failed: no matching host key format","handshake",m.KEY_EXCHANGE_FAILED)}n.serverHostKey=h[u];A&&A(`Handshake: Host key format: ${h[u]}`);const p=s.lists.cs.cipher.array;A&&A(`Handshake: (local) C->S cipher: ${p}`);A&&A(`Handshake: (remote) C->S cipher: ${o.cs.cipher}`);if(e._server){l=p;h=o.cs.cipher}else{l=o.cs.cipher;h=p}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching C->S cipher");return Q(e,"Handshake failed: no matching C->S cipher","handshake",m.KEY_EXCHANGE_FAILED)}n.cs.cipher=h[u];A&&A(`Handshake: C->S Cipher: ${h[u]}`);const E=s.lists.sc.cipher.array;A&&A(`Handshake: (local) S->C cipher: ${E}`);A&&A(`Handshake: (remote) S->C cipher: ${o.sc.cipher}`);if(e._server){l=E;h=o.sc.cipher}else{l=o.sc.cipher;h=E}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching S->C cipher");return Q(e,"Handshake failed: no matching S->C cipher","handshake",m.KEY_EXCHANGE_FAILED)}n.sc.cipher=h[u];A&&A(`Handshake: S->C cipher: ${h[u]}`);const b=s.lists.cs.mac.array;A&&A(`Handshake: (local) C->S MAC: ${b}`);A&&A(`Handshake: (remote) C->S MAC: ${o.cs.mac}`);if(C[n.cs.cipher].authLen>0){n.cs.mac="";A&&A("Handshake: C->S MAC: <implicit>")}else{if(e._server){l=b;h=o.cs.mac}else{l=o.cs.mac;h=b}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching C->S MAC");return Q(e,"Handshake failed: no matching C->S MAC","handshake",m.KEY_EXCHANGE_FAILED)}n.cs.mac=h[u];A&&A(`Handshake: C->S MAC: ${h[u]}`)}const S=s.lists.sc.mac.array;A&&A(`Handshake: (local) S->C MAC: ${S}`);A&&A(`Handshake: (remote) S->C MAC: ${o.sc.mac}`);if(C[n.sc.cipher].authLen>0){n.sc.mac="";A&&A("Handshake: S->C MAC: <implicit>")}else{if(e._server){l=S;h=o.sc.mac}else{l=o.sc.mac;h=S}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching S->C MAC");return Q(e,"Handshake failed: no matching S->C MAC","handshake",m.KEY_EXCHANGE_FAILED)}n.sc.mac=h[u];A&&A(`Handshake: S->C MAC: ${h[u]}`)}const y=s.lists.cs.compress.array;A&&A(`Handshake: (local) C->S compression: ${y}`);A&&A(`Handshake: (remote) C->S compression: ${o.cs.compress}`);if(e._server){l=y;h=o.cs.compress}else{l=o.cs.compress;h=y}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching C->S compression");return Q(e,"Handshake failed: no matching C->S compression","handshake",m.KEY_EXCHANGE_FAILED)}n.cs.compress=h[u];A&&A(`Handshake: C->S compression: ${h[u]}`);const w=s.lists.sc.compress.array;A&&A(`Handshake: (local) S->C compression: ${w}`);A&&A(`Handshake: (remote) S->C compression: ${o.sc.compress}`);if(e._server){l=w;h=o.sc.compress}else{l=o.sc.compress;h=w}for(u=0;u<h.length&&l.indexOf(h[u])===-1;++u);if(u===h.length){A&&A("Handshake: No matching S->C compression");return Q(e,"Handshake failed: no matching S->C compression","handshake",m.KEY_EXCHANGE_FAILED)}n.sc.compress=h[u];A&&A(`Handshake: S->C compression: ${h[u]}`);n.cs.lang="";n.sc.lang="";if(e._kex){if(!e._kexinit){kexinit(e)}e._decipher._onPayload=onKEXPayload.bind(e,{firstPacket:false})}e._kex=$(n,e,t);e._kex.start()}const $=(()=>{function convertToMpint(e){let t=0;let n=e.length;while(e[t]===0){++t;--n}let i;if(e[t]&128){i=Buffer.allocUnsafe(1+n);i[0]=0;e.copy(i,1,t);e=i}else if(n!==e.length){i=Buffer.allocUnsafe(n);e.copy(i,0,t);e=i}return e}class KeyExchange{constructor(e,t,n){this._protocol=t;this.sessionID=t._kex?t._kex.sessionID:undefined;this.negotiated=e;this._step=1;this._public=null;this._dh=null;this._sentNEWKEYS=false;this._receivedNEWKEYS=false;this._finished=false;this._hostVerified=false;this._kexinit=t._kexinit;this._remoteKexinit=n;this._identRaw=t._identRaw;this._remoteIdentRaw=t._remoteIdentRaw;this._hostKey=undefined;this._dhData=undefined;this._sig=undefined}finish(){if(this._finished)return false;this._finished=true;const e=this._protocol._server;const t=this.negotiated;const n=this.convertPublicKey(this._dhData);let i=this.computeSecret(this._dhData);if(i instanceof Error){i.message=`Error while computing DH secret (${this.type}): ${i.message}`;i.level="handshake";return Q(this._protocol,i,m.KEY_EXCHANGE_FAILED)}const r=o(this.hashName);j(r,e?this._remoteIdentRaw:this._identRaw);j(r,e?this._identRaw:this._remoteIdentRaw);j(r,e?this._remoteKexinit:this._kexinit);j(r,e?this._kexinit:this._remoteKexinit);const s=e?this._hostKey.getPublicSSH():this._hostKey;j(r,s);if(this.type==="groupex"){const e=this.getDHParams();const t=Buffer.allocUnsafe(4);D(t,this._minBits,0);r.update(t);D(t,this._prefBits,0);r.update(t);D(t,this._maxBits,0);r.update(t);j(r,e.prime);j(r,e.generator)}j(r,e?n:this.getPublicKey());const f=e?this.getPublicKey():n;j(r,f);j(r,i);const h=r.digest();if(!e){P.init(this._sig,0);const e=P.readString(true);if(!e){return Q(this._protocol,"Malformed packet while reading signature","handshake",m.KEY_EXCHANGE_FAILED)}if(e!==t.serverHostKey){return Q(this._protocol,`Wrong signature type: ${e}, `+`expected: ${t.serverHostKey}`,"handshake",m.KEY_EXCHANGE_FAILED)}let n=P.readString();P.clear();if(n===undefined){return Q(this._protocol,"Malformed packet while reading signature","handshake",m.KEY_EXCHANGE_FAILED)}if(!(n=O(n,e))){return Q(this._protocol,"Malformed signature","handshake",m.KEY_EXCHANGE_FAILED)}let i;{P.init(this._hostKey,0);const e=P.readString(true);const t=this._hostKey.slice(P.pos());P.clear();i=N(t,e);if(i instanceof Error){i.level="handshake";return Q(this._protocol,i,m.KEY_EXCHANGE_FAILED)}}let r;switch(this.negotiated.serverHostKey){case"rsa-sha2-256":r="sha256";break;case"rsa-sha2-512":r="sha512";break}this._protocol._debug&&this._protocol._debug("Verifying signature ...");const s=i.verify(h,n,r);if(s!==true){if(s instanceof Error){this._protocol._debug&&this._protocol._debug(`Signature verification failed: ${s.stack}`)}else{this._protocol._debug&&this._protocol._debug("Signature verification failed")}return Q(this._protocol,"Handshake failed: signature verification failed","handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Verified signature")}else{let e;switch(this.negotiated.serverHostKey){case"rsa-sha2-256":e="sha256";break;case"rsa-sha2-512":e="sha512";break}this._protocol._debug&&this._protocol._debug("Generating signature ...");let t=this._hostKey.sign(h,e);if(t instanceof Error){return Q(this._protocol,"Handshake failed: signature generation failed for "+`${this._hostKey.type} host key: ${t.message}`,"handshake",m.KEY_EXCHANGE_FAILED)}t=U(t,this._hostKey.type);if(t===false){return Q(this._protocol,"Handshake failed: signature conversion failed for "+`${this._hostKey.type} host key`,"handshake",m.KEY_EXCHANGE_FAILED)}const n=this.negotiated.serverHostKey;const i=Buffer.byteLength(n);const r=4+i+4+t.length;let o=this._protocol._packetRW.write.allocStartKEX;const l=this._protocol._packetRW.write.alloc(1+4+s.length+4+f.length+4+r,true);l[o]=w.KEXDH_REPLY;D(l,s.length,++o);l.set(s,o+=4);D(l,f.length,o+=s.length);l.set(f,o+=4);D(l,r,o+=f.length);D(l,i,o+=4);l.utf8Write(n,o+=4,i);D(l,t.length,o+=i);l.set(t,o+=4);if(this._protocol._debug){let e;switch(this.type){case"group":e="KEXDH_REPLY";break;case"groupex":e="KEXDH_GEX_REPLY";break;default:e="KEXECDH_REPLY"}this._protocol._debug(`Outbound: Sending ${e}`)}this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(l,true))}trySendNEWKEYS(this);const completeHandshake=()=>{if(!this.sessionID)this.sessionID=h;{const e=Buffer.allocUnsafe(4+i.length);D(e,i.length,0);e.set(i,4);i=e}const n=C[t.cs.cipher];const r=C[t.sc.cipher];const s=generateKEXVal(n.ivLen,this.hashName,i,h,this.sessionID,"A");const o=generateKEXVal(r.ivLen,this.hashName,i,h,this.sessionID,"B");const f=generateKEXVal(n.keyLen,this.hashName,i,h,this.sessionID,"C");const l=generateKEXVal(r.keyLen,this.hashName,i,h,this.sessionID,"D");let u;let A;if(!n.authLen){u=R[t.cs.mac];A=generateKEXVal(u.len,this.hashName,i,h,this.sessionID,"E")}let g;let _;if(!r.authLen){g=R[t.sc.mac];_=generateKEXVal(g.len,this.hashName,i,h,this.sessionID,"F")}const p={inbound:{onPayload:this._protocol._onPayload,seqno:this._protocol._decipher.inSeqno,decipherInfo:!e?r:n,decipherIV:!e?o:s,decipherKey:!e?l:f,macInfo:!e?g:u,macKey:!e?_:A},outbound:{onWrite:this._protocol._onWrite,seqno:this._protocol._cipher.outSeqno,cipherInfo:e?r:n,cipherIV:e?o:s,cipherKey:e?l:f,macInfo:e?g:u,macKey:e?_:A}};this._protocol._cipher&&this._protocol._cipher.free();this._protocol._decipher&&this._protocol._decipher.free();this._protocol._cipher=B(p);this._protocol._decipher=k(p);const E={read:undefined,write:undefined};switch(t.cs.compress){case"zlib":if(e)E.read=new F;else E.write=new W(this._protocol);break;case"zlib@openssh.com":if(this._protocol._authenticated){if(e)E.read=new F;else E.write=new W(this._protocol);break}default:if(e)E.read=new v;else E.write=new H(this._protocol)}switch(t.sc.compress){case"zlib":if(e)E.write=new W(this._protocol);else E.read=new F;break;case"zlib@openssh.com":if(this._protocol._authenticated){if(e)E.write=new W(this._protocol);else E.read=new F;break}default:if(e)E.write=new H(this._protocol);else E.read=new v}this._protocol._packetRW.read.cleanup();this._protocol._packetRW.write.cleanup();this._protocol._packetRW=E;this._public=null;this._dh=null;this._kexinit=this._protocol._kexinit=undefined;this._remoteKexinit=undefined;this._identRaw=undefined;this._remoteIdentRaw=undefined;this._hostKey=undefined;this._dhData=undefined;this._sig=undefined;this._protocol._onHandshakeComplete(t);return false};if(!e)return completeHandshake();this.finish=completeHandshake}start(){if(!this._protocol._server){if(this._protocol._debug){let e;switch(this.type){case"group":e="KEXDH_INIT";break;default:e="KEXECDH_INIT"}this._protocol._debug(`Outbound: Sending ${e}`)}const e=this.getPublicKey();let t=this._protocol._packetRW.write.allocStartKEX;const n=this._protocol._packetRW.write.alloc(1+4+e.length,true);n[t]=w.KEXDH_INIT;D(n,e.length,++t);n.set(e,t+=4);this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(n,true))}}getPublicKey(){this.generateKeys();const e=this._public;if(e)return this.convertPublicKey(e)}convertPublicKey(e){let t;let n=0;let i=e.length;while(e[n]===0){++n;--i}if(e[n]&128){t=Buffer.allocUnsafe(1+i);t[0]=0;e.copy(t,1,n);return t}if(i!==e.length){t=Buffer.allocUnsafe(i);e.copy(t,0,n);e=t}return e}computeSecret(e){this.generateKeys();try{return convertToMpint(this._dh.computeSecret(e))}catch(e){return e}}parse(e){const t=e[0];switch(this._step){case 1:if(this._protocol._server){if(t!==w.KEXDH_INIT){return Q(this._protocol,`Received packet ${t} instead of ${w.KEXDH_INIT}`,"handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Received DH Init");P.init(e,1);const n=P.readString();P.clear();if(n===undefined){return Q(this._protocol,"Received malformed KEX*_INIT","handshake",m.KEY_EXCHANGE_FAILED)}this._dhData=n;let i=this._protocol._hostKeys[this.negotiated.serverHostKey];if(Array.isArray(i))i=i[0];this._hostKey=i;this.finish()}else{if(t!==w.KEXDH_REPLY){return Q(this._protocol,`Received packet ${t} instead of ${w.KEXDH_REPLY}`,"handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Received DH Reply");P.init(e,1);let n;let i;let r;if((n=P.readString())===undefined||(i=P.readString())===undefined||(r=P.readString())===undefined){P.clear();return Q(this._protocol,"Received malformed KEX*_REPLY","handshake",m.KEY_EXCHANGE_FAILED)}P.clear();P.init(n,0);const s=P.readString(true);P.clear();if(s===undefined){return Q(this._protocol,"Received malformed host public key","handshake",m.KEY_EXCHANGE_FAILED)}if(s!==this.negotiated.serverHostKey){switch(this.negotiated.serverHostKey){case"rsa-sha2-256":case"rsa-sha2-512":if(s==="ssh-rsa")break;default:return Q(this._protocol,"Host key does not match negotiated type","handshake",m.KEY_EXCHANGE_FAILED)}}this._hostKey=n;this._dhData=i;this._sig=r;let o=false;let f;if(this._protocol._hostVerifier===undefined){f=true;this._protocol._debug&&this._protocol._debug("Host accepted by default (no verification)")}else{f=this._protocol._hostVerifier(n,(e=>{if(o)return;o=true;if(e===false){this._protocol._debug&&this._protocol._debug("Host denied (verification failed)");return Q(this._protocol,"Host denied (verification failed)","handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Host accepted (verified)");this._hostVerified=true;if(this._receivedNEWKEYS)this.finish();else trySendNEWKEYS(this)}))}if(f===undefined){++this._step;return}o=true;if(f===false){this._protocol._debug&&this._protocol._debug("Host denied (verification failed)");return Q(this._protocol,"Host denied (verification failed)","handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Host accepted (verified)");this._hostVerified=true;trySendNEWKEYS(this)}++this._step;break;case 2:if(t!==w.NEWKEYS){return Q(this._protocol,`Received packet ${t} instead of ${w.NEWKEYS}`,"handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Inbound: NEWKEYS");this._receivedNEWKEYS=true;++this._step;if(this._protocol._server||this._hostVerified)return this.finish();return false;default:return Q(this._protocol,`Received unexpected packet ${t} after NEWKEYS`,"handshake",m.KEY_EXCHANGE_FAILED)}}}class Curve25519Exchange extends KeyExchange{constructor(e,...t){super(...t);this.type="25519";this.hashName=e;this._keys=null}generateKeys(){if(!this._keys)this._keys=l("x25519")}getPublicKey(){this.generateKeys();const e=this._keys.publicKey.export({type:"spki",format:"der"});return e.slice(-32)}convertPublicKey(e){let t;let n=0;let i=e.length;while(e[n]===0){++n;--i}if(e.length===32)return e;if(i!==e.length){t=Buffer.allocUnsafe(i);e.copy(t,0,n);e=t}return e}computeSecret(e){this.generateKeys();try{const t=new A.Writer;t.startSequence();t.startSequence();t.writeOID("1.3.101.110");t.endSequence();t.startSequence(A.BitString);t.writeByte(0);t._ensure(e.length);e.copy(t._buf,t._offset,0,e.length);t._offset+=e.length;t.endSequence();t.endSequence();return convertToMpint(h({privateKey:this._keys.privateKey,publicKey:f({key:t.buffer,type:"spki",format:"der"})}))}catch(e){return e}}}class ECDHExchange extends KeyExchange{constructor(e,t,...n){super(...n);this.type="ecdh";this.curveName=e;this.hashName=t}generateKeys(){if(!this._dh){this._dh=s(this.curveName);this._public=this._dh.generateKeys()}}}class DHGroupExchange extends KeyExchange{constructor(e,...t){super(...t);this.type="groupex";this.hashName=e;this._prime=null;this._generator=null;this._minBits=M;this._prefBits=dhEstimate(this.negotiated);if(this._protocol._compatFlags&g.BUG_DHGEX_LARGE)this._prefBits=Math.min(this._prefBits,4096);this._maxBits=q}start(){if(this._protocol._server)return;this._protocol._debug&&this._protocol._debug("Outbound: Sending KEXDH_GEX_REQUEST");let e=this._protocol._packetRW.write.allocStartKEX;const t=this._protocol._packetRW.write.alloc(1+4+4+4,true);t[e]=w.KEXDH_GEX_REQUEST;D(t,this._minBits,++e);D(t,this._prefBits,e+=4);D(t,this._maxBits,e+=4);this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(t,true))}generateKeys(){if(!this._dh&&this._prime&&this._generator){this._dh=i(this._prime,this._generator);this._public=this._dh.generateKeys()}}setDHParams(e,t){if(!Buffer.isBuffer(e))throw new Error("Invalid prime value");if(!Buffer.isBuffer(t))throw new Error("Invalid generator value");this._prime=e;this._generator=t}getDHParams(){if(this._dh){return{prime:convertToMpint(this._dh.getPrime()),generator:convertToMpint(this._dh.getGenerator())}}}parse(e){const t=e[0];switch(this._step){case 1:if(this._protocol._server){if(t!==w.KEXDH_GEX_REQUEST){return Q(this._protocol,`Received packet ${t} instead of `+w.KEXDH_GEX_REQUEST,"handshake",m.KEY_EXCHANGE_FAILED)}return Q(this._protocol,"Group exchange not implemented for server","handshake",m.KEY_EXCHANGE_FAILED)}if(t!==w.KEXDH_GEX_GROUP){return Q(this._protocol,`Received packet ${t} instead of ${w.KEXDH_GEX_GROUP}`,"handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Received DH GEX Group");P.init(e,1);let n;let i;if((n=P.readString())===undefined||(i=P.readString())===undefined){P.clear();return Q(this._protocol,"Received malformed KEXDH_GEX_GROUP","handshake",m.KEY_EXCHANGE_FAILED)}P.clear();this.setDHParams(n,i);this.generateKeys();const r=this.getPublicKey();this._protocol._debug&&this._protocol._debug("Outbound: Sending KEXDH_GEX_INIT");let s=this._protocol._packetRW.write.allocStartKEX;const o=this._protocol._packetRW.write.alloc(1+4+r.length,true);o[s]=w.KEXDH_GEX_INIT;D(o,r.length,++s);o.set(r,s+=4);this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(o,true));++this._step;break;case 2:if(this._protocol._server){if(t!==w.KEXDH_GEX_INIT){return Q(this._protocol,`Received packet ${t} instead of ${w.KEXDH_GEX_INIT}`,"handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Received DH GEX Init");return Q(this._protocol,"Group exchange not implemented for server","handshake",m.KEY_EXCHANGE_FAILED)}else if(t!==w.KEXDH_GEX_REPLY){return Q(this._protocol,`Received packet ${t} instead of ${w.KEXDH_GEX_REPLY}`,"handshake",m.KEY_EXCHANGE_FAILED)}this._protocol._debug&&this._protocol._debug("Received DH GEX Reply");this._step=1;e[0]=w.KEXDH_REPLY;this.parse=KeyExchange.prototype.parse;this.parse(e)}}}class DHExchange extends KeyExchange{constructor(e,t,...n){super(...n);this.type="group";this.groupName=e;this.hashName=t}start(){if(!this._protocol._server){this._protocol._debug&&this._protocol._debug("Outbound: Sending KEXDH_INIT");const e=this.getPublicKey();let t=this._protocol._packetRW.write.allocStartKEX;const n=this._protocol._packetRW.write.alloc(1+4+e.length,true);n[t]=w.KEXDH_INIT;D(n,e.length,++t);n.set(e,t+=4);this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(n,true))}}generateKeys(){if(!this._dh){this._dh=r(this.groupName);this._public=this._dh.generateKeys()}}getDHParams(){if(this._dh){return{prime:convertToMpint(this._dh.getPrime()),generator:convertToMpint(this._dh.getGenerator())}}}}return(e,...t)=>{if(typeof e!=="object"||e===null)throw new Error("Invalid negotiated argument");const n=e.kex;if(typeof n==="string"){t=[e,...t];switch(n){case"curve25519-sha256":case"curve25519-sha256@libssh.org":if(!_)break;return new Curve25519Exchange("sha256",...t);case"ecdh-sha2-nistp256":return new ECDHExchange("prime256v1","sha256",...t);case"ecdh-sha2-nistp384":return new ECDHExchange("secp384r1","sha384",...t);case"ecdh-sha2-nistp521":return new ECDHExchange("secp521r1","sha512",...t);case"diffie-hellman-group1-sha1":return new DHExchange("modp2","sha1",...t);case"diffie-hellman-group14-sha1":return new DHExchange("modp14","sha1",...t);case"diffie-hellman-group14-sha256":return new DHExchange("modp14","sha256",...t);case"diffie-hellman-group15-sha512":return new DHExchange("modp15","sha512",...t);case"diffie-hellman-group16-sha512":return new DHExchange("modp16","sha512",...t);case"diffie-hellman-group17-sha512":return new DHExchange("modp17","sha512",...t);case"diffie-hellman-group18-sha512":return new DHExchange("modp18","sha512",...t);case"diffie-hellman-group-exchange-sha1":return new DHGroupExchange("sha1",...t);case"diffie-hellman-group-exchange-sha256":return new DHGroupExchange("sha256",...t)}throw new Error(`Unsupported key exchange algorithm: ${n}`)}throw new Error(`Invalid key exchange type: ${n}`)}})();const Y=(()=>{const e=["kex","serverHostKey",["cs","cipher"],["sc","cipher"],["cs","mac"],["sc","mac"],["cs","compress"],["sc","compress"],["cs","lang"],["sc","lang"]];return class KexInit{constructor(t){if(typeof t!=="object"||t===null)throw new TypeError("Argument must be an object");const n={kex:undefined,serverHostKey:undefined,cs:{cipher:undefined,mac:undefined,compress:undefined,lang:undefined},sc:{cipher:undefined,mac:undefined,compress:undefined,lang:undefined},all:undefined};let i=0;for(const r of e){let e;let s;let o;let f;if(typeof r==="string"){e=n;s=t[r];o=f=r}else{const i=r[0];e=n[i];f=r[1];s=t[i][f];o=`${i}.${f}`}const h={array:undefined,buffer:undefined};if(Buffer.isBuffer(s)){h.array=(""+s).split(",");h.buffer=s;i+=4+s.length}else{if(typeof s==="string")s=s.split(",");if(Array.isArray(s)){h.array=s;h.buffer=Buffer.from(s.join(","))}else{throw new TypeError(`Invalid \`${o}\` type: ${typeof s}`)}i+=4+h.buffer.length}e[f]=h}const r=Buffer.allocUnsafe(i);n.all=r;let s=0;for(const t of e){let e;if(typeof t==="string")e=n[t].buffer;else e=n[t[0]][t[1]].buffer;s=D(r,e.length,s);r.set(e,s);s+=e.length}this.totalSize=i;this.lists=n}copyAllTo(e,t){const n=this.lists.all;if(typeof t!=="number")throw new TypeError(`Invalid offset value: ${typeof t}`);if(e.length-t<n.length)throw new Error("Insufficient space to copy list");e.set(n,t);return n.length}}})();const j=(()=>{const e=Buffer.allocUnsafe(4);return(t,n)=>{D(e,n.length,0);t.update(e);t.update(n)}})();function generateKEXVal(e,t,n,i,r,s){let f;if(e){let h=o(t).update(n).update(i).update(s).update(r).digest();while(h.length<e){const e=o(t).update(n).update(i).update(h).digest();const r=Buffer.allocUnsafe(h.length+e.length);r.set(h,0);r.set(e,h.length);h=r}if(h.length===e)f=h;else f=new L(h.buffer,h.byteOffset,e)}else{f=G}return f}function onKEXPayload(e,t){if(t.length===0){this._debug&&this._debug("Inbound: Skipping empty packet payload");return}if(this._skipNextInboundPacket){this._skipNextInboundPacket=false;return}t=this._packetRW.read.read(t);const i=t[0];switch(i){case w.DISCONNECT:case w.IGNORE:case w.UNIMPLEMENTED:case w.DEBUG:if(!x)x=n(958);return x[i](this,t);case w.KEXINIT:if(!e.firstPacket){return Q(this,"Received extra KEXINIT during handshake","handshake",m.KEY_EXCHANGE_FAILED)}e.firstPacket=false;return handleKexInit(this,t);default:if(i<20||i>49){return Q(this,`Received unexpected packet type ${i}`,"handshake",m.KEY_EXCHANGE_FAILED)}}return this._kex.parse(t)}function dhEstimate(e){const t=C[e.cs.cipher];const n=C[e.sc.cipher];const i=Math.max(0,t.sslName==="des-ede3-cbc"?14:t.keyLen,t.blockLen,t.ivLen,n.sslName==="des-ede3-cbc"?14:n.keyLen,n.blockLen,n.ivLen)*8;if(i<=112)return 2048;if(i<=128)return 3072;if(i<=192)return 7680;return 8192}function trySendNEWKEYS(e){if(!e._sentNEWKEYS){e._protocol._debug&&e._protocol._debug("Outbound: Sending NEWKEYS");const t=e._protocol._packetRW.write.allocStartKEX;const n=e._protocol._packetRW.write.alloc(1,true);n[t]=w.NEWKEYS;e._protocol._cipher.encrypt(e._protocol._packetRW.write.finalize(n,true));e._sentNEWKEYS=true}}e.exports={KexInit:Y,kexinit:kexinit,onKEXPayload:onKEXPayload,DEFAULT_KEXINIT:new Y({kex:p,serverHostKey:E,cs:{cipher:b,mac:S,compress:y,lang:[]},sc:{cipher:b,mac:S,compress:y,lang:[]}}),HANDLERS:{[w.KEXINIT]:handleKexInit}}},887:(e,t,n)=>{const{createDecipheriv:i,createHash:r,createHmac:s,createSign:o,createVerify:f,getCiphers:h,sign:l,verify:u}=n(113);const A=h();const{Ber:g}=n(461);const{CIPHER_INFO:_}=n(298);const{eddsaSupported:p}=n(434);const{bufferSlice:E,makeBufferParser:b,readString:S,readUInt32BE:y,writeUInt32BE:m}=n(223);const w=Symbol("Hash Algorithm");const C=Symbol("Private key PEM");const B=Symbol("Public key PEM");const k=Symbol("Public key SSH");const R=Symbol("Decrypted Key");const N=Object.create(null);{const e=Object.keys(_);for(let t=0;t<e.length;++t){const n=_[e[t]].sslName;if(!n||N[n])continue;N[n]=_[e[t]]}}const T=b();function makePEM(e,t){t=t.base64Slice(0,t.length);let n=t.replace(/.{64}/g,"$&\n");if(t.length&63)n+="\n";return`-----BEGIN ${e} KEY-----\n${n}-----END ${e} KEY-----`}function combineBuffers(e,t){const n=Buffer.allocUnsafe(e.length+t.length);n.set(e,0);n.set(t,e.length);return n}function skipFields(e,t){const n=e.length;let i=e._pos||0;for(let r=0;r<t;++r){const t=n-i;if(i>=n||t<4)return false;const r=y(e,i);if(t<4+r)return false;i+=4+r}e._pos=i;return true}function genOpenSSLRSAPub(e,t){const n=new g.Writer;n.startSequence();n.startSequence();n.writeOID("1.2.840.113549.1.1.1");n.writeNull();n.endSequence();n.startSequence(g.BitString);n.writeByte(0);n.startSequence();n.writeBuffer(e,g.Integer);n.writeBuffer(t,g.Integer);n.endSequence();n.endSequence();n.endSequence();return makePEM("PUBLIC",n.buffer)}function genOpenSSHRSAPub(e,t){const n=Buffer.allocUnsafe(4+7+4+t.length+4+e.length);m(n,7,0);n.utf8Write("ssh-rsa",4,7);let i=4+7;m(n,t.length,i);n.set(t,i+=4);m(n,e.length,i+=t.length);n.set(e,i+4);return n}const P=(()=>{function genRSAASN1Buf(e,t,n,i,r,s,o,f){const h=new g.Writer;h.startSequence();h.writeInt(0,g.Integer);h.writeBuffer(e,g.Integer);h.writeBuffer(t,g.Integer);h.writeBuffer(n,g.Integer);h.writeBuffer(i,g.Integer);h.writeBuffer(r,g.Integer);h.writeBuffer(s,g.Integer);h.writeBuffer(o,g.Integer);h.writeBuffer(f,g.Integer);h.endSequence();return h.buffer}function bigIntFromBuffer(e){return BigInt(`0x${e.hexSlice(0,e.length)}`)}function bigIntToBuffer(e){let t=e.toString(16);if((t.length&1)!==0){t=`0${t}`}else{const e=t.charCodeAt(0);if(e===56||e===57||e>=97&&e<=102){t=`00${t}`}}return Buffer.from(t,"hex")}return function genOpenSSLRSAPriv(e,t,n,i,r,s){const o=bigIntFromBuffer(n);const f=bigIntToBuffer(o%(bigIntFromBuffer(r)-1n));const h=bigIntToBuffer(o%(bigIntFromBuffer(s)-1n));return makePEM("RSA PRIVATE",genRSAASN1Buf(e,t,n,r,s,f,h,i))}})();function genOpenSSLDSAPub(e,t,n,i){const r=new g.Writer;r.startSequence();r.startSequence();r.writeOID("1.2.840.10040.4.1");r.startSequence();r.writeBuffer(e,g.Integer);r.writeBuffer(t,g.Integer);r.writeBuffer(n,g.Integer);r.endSequence();r.endSequence();r.startSequence(g.BitString);r.writeByte(0);r.writeBuffer(i,g.Integer);r.endSequence();r.endSequence();return makePEM("PUBLIC",r.buffer)}function genOpenSSHDSAPub(e,t,n,i){const r=Buffer.allocUnsafe(4+7+4+e.length+4+t.length+4+n.length+4+i.length);m(r,7,0);r.utf8Write("ssh-dss",4,7);let s=4+7;m(r,e.length,s);r.set(e,s+=4);m(r,t.length,s+=e.length);r.set(t,s+=4);m(r,n.length,s+=t.length);r.set(n,s+=4);m(r,i.length,s+=n.length);r.set(i,s+4);return r}function genOpenSSLDSAPriv(e,t,n,i,r){const s=new g.Writer;s.startSequence();s.writeInt(0,g.Integer);s.writeBuffer(e,g.Integer);s.writeBuffer(t,g.Integer);s.writeBuffer(n,g.Integer);s.writeBuffer(i,g.Integer);s.writeBuffer(r,g.Integer);s.endSequence();return makePEM("DSA PRIVATE",s.buffer)}function genOpenSSLEdPub(e){const t=new g.Writer;t.startSequence();t.startSequence();t.writeOID("1.3.101.112");t.endSequence();t.startSequence(g.BitString);t.writeByte(0);t._ensure(e.length);t._buf.set(e,t._offset);t._offset+=e.length;t.endSequence();t.endSequence();return makePEM("PUBLIC",t.buffer)}function genOpenSSHEdPub(e){const t=Buffer.allocUnsafe(4+11+4+e.length);m(t,11,0);t.utf8Write("ssh-ed25519",4,11);m(t,e.length,15);t.set(e,19);return t}function genOpenSSLECDSAPub(e,t){const n=new g.Writer;n.startSequence();n.startSequence();n.writeOID("1.2.840.10045.2.1");n.writeOID(e);n.endSequence();n.startSequence(g.BitString);n.writeByte(0);n._ensure(t.length);n._buf.set(t,n._offset);n._offset+=t.length;n.endSequence();n.endSequence();return makePEM("PUBLIC",n.buffer)}function genOpenSSHECDSAPub(e,t){let n;switch(e){case"1.2.840.10045.3.1.7":n="nistp256";break;case"1.3.132.0.34":n="nistp384";break;case"1.3.132.0.35":n="nistp521";break;default:return}const i=Buffer.allocUnsafe(4+19+4+8+4+t.length);m(i,19,0);i.utf8Write(`ecdsa-sha2-${n}`,4,19);m(i,8,23);i.utf8Write(n,27,8);m(i,t.length,35);i.set(t,39);return i}const U={sign:(()=>{if(typeof l==="function"){return function sign(e,t){const n=this[C];if(n===null)return new Error("No private key available");if(!t||typeof t!=="string")t=this[w];try{return l(t,e,n)}catch(e){return e}}}return function sign(e,t){const n=this[C];if(n===null)return new Error("No private key available");if(!t||typeof t!=="string")t=this[w];const i=o(t);i.update(e);try{return i.sign(n)}catch(e){return e}}})(),verify:(()=>{if(typeof u==="function"){return function verify(e,t,n){const i=this[B];if(i===null)return new Error("No public key available");if(!n||typeof n!=="string")n=this[w];try{return u(n,e,i,t)}catch(e){return e}}}return function verify(e,t,n){const i=this[B];if(i===null)return new Error("No public key available");if(!n||typeof n!=="string")n=this[w];const r=f(n);r.update(e);try{return r.verify(i,t)}catch(e){return e}}})(),isPrivateKey:function isPrivateKey(){return this[C]!==null},getPrivatePEM:function getPrivatePEM(){return this[C]},getPublicPEM:function getPublicPEM(){return this[B]},getPublicSSH:function getPublicSSH(){return this[k]},equals:function equals(e){const t=parseKey(e);if(t instanceof Error)return false;return this.type===t.type&&this[C]===t[C]&&this[B]===t[B]&&this[k]===t[k]}};function OpenSSH_Old_Private(e,t,n,i,r,s,o){this.type=e;this.comment=t;this[C]=n;this[B]=i;this[k]=r;this[w]=s;this[R]=o}OpenSSH_Old_Private.prototype=U;{const e=/^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;OpenSSH_Old_Private.parse=(t,n)=>{const s=e.exec(t);if(s===null)return null;let o=Buffer.from(s[3],"base64");let f=s[2];let h=false;if(f!==undefined){f=f.split(/\r\n|\n/g);for(let e=0;e<f.length;++e){const t=f[e];let s=t.indexOf(":");if(t.slice(0,s)==="DEK-Info"){const e=t.slice(s+2);s=e.indexOf(",");if(s===-1)continue;const f=e.slice(0,s).toLowerCase();if(A.indexOf(f)===-1){return new Error(`Cipher (${f}) not supported `+"for encrypted OpenSSH private key")}const l=N[f];if(!l){return new Error(`Cipher (${f}) not supported `+"for encrypted OpenSSH private key")}const u=Buffer.from(e.slice(s+1),"hex");if(u.length!==l.ivLen)return new Error("Malformed encrypted OpenSSH private key");if(!n){return new Error("Encrypted OpenSSH private key detected, but no passphrase given")}const g=E(u,0,8);let _=r("md5").update(n).update(g).digest();while(_.length<l.keyLen){_=combineBuffers(_,r("md5").update(_).update(n).update(g).digest())}if(_.length>l.keyLen)_=E(_,0,l.keyLen);try{const e=i(f,_,u);e.setAutoPadding(false);o=combineBuffers(e.update(o),e.final());h=true}catch(e){return e}}}}let l;let u;let _;let p;let b;let S;let y="Malformed OpenSSH private key";if(h)y+=". Bad passphrase?";switch(s[1]){case"RSA":l="ssh-rsa";u=makePEM("RSA PRIVATE",o);try{S=new g.Reader(o);S.readSequence();S.readInt();const e=S.readString(g.Integer,true);if(e===null)return new Error(y);const t=S.readString(g.Integer,true);if(t===null)return new Error(y);_=genOpenSSLRSAPub(e,t);p=genOpenSSHRSAPub(e,t)}catch{return new Error(y)}b="sha1";break}return new OpenSSH_Old_Private(l,"",u,_,p,b,h)}}function PPK_Private(e,t,n,i,r,s,o){this.type=e;this.comment=t;this[C]=n;this[B]=i;this[k]=r;this[w]=s;this[R]=o}PPK_Private.prototype=U;{const e=Buffer.alloc(0);const t=Buffer.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);const n=Buffer.from([0,0,0,0]);const o=Buffer.from([0,0,0,1]);const f=/^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;PPK_Private.parse=(h,l)=>{const u=f.exec(h);if(u===null)return null;const A=u[2];const g=A!=="none";if(g&&!l){return new Error("Encrypted PPK private key detected, but no passphrase given")}let p=Buffer.from(u[5],"base64");if(g){const e=_[A];let s=combineBuffers(r("sha1").update(n).update(l).digest(),r("sha1").update(o).update(l).digest());if(s.length>e.keyLen)s=E(s,0,e.keyLen);try{const n=i(e.sslName,s,t);n.setAutoPadding(false);p=combineBuffers(n.update(p),n.final())}catch(e){return e}}const b=u[1];const y=u[3];const w=Buffer.from(u[4],"base64");const C=u[6];const B=b.length;const k=A.length;const R=Buffer.byteLength(y);const N=w.length;const T=p.length;const U=Buffer.allocUnsafe(4+B+4+k+4+R+4+N+4+T);let Q=0;m(U,B,Q);U.utf8Write(b,Q+=4,B);m(U,k,Q+=B);U.utf8Write(A,Q+=4,k);m(U,R,Q+=k);U.utf8Write(y,Q+=4,R);m(U,N,Q+=R);U.set(w,Q+=4);m(U,T,Q+=N);U.set(p,Q+4);if(!l)l=e;const L=s("sha1",r("sha1").update("putty-private-key-file-mac-key").update(l).digest()).update(U).digest("hex");if(L!==C){if(g){return new Error("PPK private key integrity check failed -- bad passphrase?")}return new Error("PPK private key integrity check failed")}let O;let D;let v;w._pos=0;skipFields(w,1);switch(b){case"ssh-rsa":{const e=S(w,w._pos);if(e===undefined)return new Error("Malformed PPK public key");const t=S(w,w._pos);if(t===undefined)return new Error("Malformed PPK public key");const n=S(p,0);if(n===undefined)return new Error("Malformed PPK private key");const i=S(p,p._pos);if(i===undefined)return new Error("Malformed PPK private key");const r=S(p,p._pos);if(r===undefined)return new Error("Malformed PPK private key");const s=S(p,p._pos);if(s===undefined)return new Error("Malformed PPK private key");O=genOpenSSLRSAPub(t,e);D=genOpenSSHRSAPub(t,e);v=P(t,e,n,s,i,r);break}case"ssh-dss":{const e=S(w,w._pos);if(e===undefined)return new Error("Malformed PPK public key");const t=S(w,w._pos);if(t===undefined)return new Error("Malformed PPK public key");const n=S(w,w._pos);if(n===undefined)return new Error("Malformed PPK public key");const i=S(w,w._pos);if(i===undefined)return new Error("Malformed PPK public key");const r=S(p,0);if(r===undefined)return new Error("Malformed PPK private key");O=genOpenSSLDSAPub(e,t,n,i);D=genOpenSSHDSAPub(e,t,n,i);v=genOpenSSLDSAPriv(e,t,n,i,r);break}}return new PPK_Private(b,y,v,O,D,"sha1",g)}}function OpenSSH_Public(e,t,n,i,r){this.type=e;this.comment=t;this[C]=null;this[B]=n;this[k]=i;this[w]=r;this[R]=false}OpenSSH_Public.prototype=U;{let e;if(p)e=/^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;else e=/^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;OpenSSH_Public.parse=t=>{const n=e.exec(t);if(n===null)return null;const i=n[1];const r=n[2];const s=Buffer.from(n[3],"base64");const o=n[4]||"";const f=S(s,s._pos,true);if(f===undefined||f.indexOf(r)!==0)return new Error("Malformed OpenSSH public key");return parseDER(s,r,o,i)}}function RFC4716_Public(e,t,n,i,r){this.type=e;this.comment=t;this[C]=null;this[B]=n;this[k]=i;this[w]=r;this[R]=false}RFC4716_Public.prototype=U;{const e=/^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/;const t=/^[A-Z0-9a-z/+=\r\n]+$/;const n=/^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm;const i=/\\\r?\n/g;RFC4716_Public.parse=r=>{let s=e.exec(r);if(s===null)return null;const o=s[1];let f=0;let h="";while(s=n.exec(o)){const e=s[1];const t=s[2].replace(i,"");if(t.length>1024){n.lastIndex=0;return new Error("Malformed RFC4716 public key")}f=n.lastIndex;if(e.toLowerCase()==="comment"){h=t;if(h.length>1&&h.charCodeAt(0)===34&&h.charCodeAt(h.length-1)===34){h=h.slice(1,-1)}}}let l=o.slice(f);if(!t.test(l))return new Error("Malformed RFC4716 public key");l=Buffer.from(l,"base64");const u=S(l,0,true);if(u===undefined)return new Error("Malformed RFC4716 public key");let A=null;let g=null;switch(u){case"ssh-rsa":{const e=S(l,l._pos);if(e===undefined)return new Error("Malformed RFC4716 public key");const t=S(l,l._pos);if(t===undefined)return new Error("Malformed RFC4716 public key");A=genOpenSSLRSAPub(t,e);g=genOpenSSHRSAPub(t,e);break}case"ssh-dss":{const e=S(l,l._pos);if(e===undefined)return new Error("Malformed RFC4716 public key");const t=S(l,l._pos);if(t===undefined)return new Error("Malformed RFC4716 public key");const n=S(l,l._pos);if(n===undefined)return new Error("Malformed RFC4716 public key");const i=S(l,l._pos);if(i===undefined)return new Error("Malformed RFC4716 public key");A=genOpenSSLDSAPub(e,t,n,i);g=genOpenSSHDSAPub(e,t,n,i);break}default:return new Error("Malformed RFC4716 public key")}return new RFC4716_Public(u,h,A,g,"sha1")}}function parseDER(e,t,n,i){if(!isSupportedKeyType(t))return new Error(`Unsupported OpenSSH public key type: ${t}`);let r;let s;let o=null;let f=null;switch(t){case"ssh-rsa":{const t=S(e,e._pos||0);if(t===undefined)return new Error("Malformed OpenSSH public key");const n=S(e,e._pos);if(n===undefined)return new Error("Malformed OpenSSH public key");o=genOpenSSLRSAPub(n,t);f=genOpenSSHRSAPub(n,t);r="sha1";break}case"ssh-dss":{const t=S(e,e._pos||0);if(t===undefined)return new Error("Malformed OpenSSH public key");const n=S(e,e._pos);if(n===undefined)return new Error("Malformed OpenSSH public key");const i=S(e,e._pos);if(i===undefined)return new Error("Malformed OpenSSH public key");const s=S(e,e._pos);if(s===undefined)return new Error("Malformed OpenSSH public key");o=genOpenSSLDSAPub(t,n,i,s);f=genOpenSSHDSAPub(t,n,i,s);r="sha1";break}case"ssh-ed25519":{const t=S(e,e._pos||0);if(t===undefined||t.length!==32)return new Error("Malformed OpenSSH public key");o=genOpenSSLEdPub(t);f=genOpenSSHEdPub(t);r=null;break}case"ecdsa-sha2-nistp256":r="sha256";s="1.2.840.10045.3.1.7";case"ecdsa-sha2-nistp384":if(r===undefined){r="sha384";s="1.3.132.0.34"}case"ecdsa-sha2-nistp521":{if(r===undefined){r="sha512";s="1.3.132.0.35"}if(!skipFields(e,1))return new Error("Malformed OpenSSH public key");const t=S(e,e._pos||0);if(t===undefined)return new Error("Malformed OpenSSH public key");o=genOpenSSLECDSAPub(s,t);f=genOpenSSHECDSAPub(s,t);break}default:return new Error(`Unsupported OpenSSH public key type: ${t}`)}return new OpenSSH_Public(i,n,o,f,r)}function isSupportedKeyType(e){switch(e){case"ssh-rsa":case"ssh-dss":case"ecdsa-sha2-nistp256":case"ecdsa-sha2-nistp384":case"ecdsa-sha2-nistp521":return true;case"ssh-ed25519":if(p)return true;default:return false}}function isParsedKey(e){if(!e)return false;return typeof e[R]==="boolean"}function parseKey(e,t){if(isParsedKey(e))return e;let n;if(Buffer.isBuffer(e)){n=e;e=e.utf8Slice(0,e.length).trim()}else if(typeof e==="string"){e=e.trim()}else{return new Error("Key data must be a Buffer or string")}if(t!=undefined){if(typeof t==="string")t=Buffer.from(t);else if(!Buffer.isBuffer(t))return new Error("Passphrase must be a string or Buffer when supplied")}let i;if((i=OpenSSH_Old_Private.parse(e,t))!==null)return i;if((i=PPK_Private.parse(e,t))!==null)return i;if((i=OpenSSH_Public.parse(e))!==null)return i;if((i=RFC4716_Public.parse(e))!==null)return i;if(n){T.init(n,0);const t=T.readString(true);if(t!==undefined){e=T.readRaw();if(e!==undefined){i=parseDER(e,t,"",t);if(i instanceof Error)i=null}}T.clear()}if(i)return i;return new Error("Unsupported key format")}e.exports={isParsedKey:isParsedKey,isSupportedKeyType:isSupportedKeyType,parseDERKey:(e,t)=>parseDER(e,t,"",t),parseKey:parseKey}},379:(e,t,n)=>{const i=n(491);const{inspect:r}=n(837);function addNumericalSeparator(e){let t="";let n=e.length;const i=e[0]==="-"?1:0;for(;n>=i+4;n-=3)t=`_${e.slice(n-3,n)}${t}`;return`${e.slice(0,n)}${t}`}function oneOf(e,t){i(typeof t==="string","`thing` has to be of type string");if(Array.isArray(e)){const n=e.length;i(n>0,"At least one expected value needs to be specified");e=e.map((e=>String(e)));if(n>2){return`one of ${t} ${e.slice(0,n-1).join(", ")}, or `+e[n-1]}else if(n===2){return`one of ${t} ${e[0]} or ${e[1]}`}return`of ${t} ${e[0]}`}return`of ${t} ${String(e)}`}t.ERR_INTERNAL_ASSERTION=class ERR_INTERNAL_ASSERTION extends Error{constructor(e){super();Error.captureStackTrace(this,ERR_INTERNAL_ASSERTION);const t="This is caused by either a bug in ssh2 "+"or incorrect usage of ssh2 internals.\n"+"Please open an issue with this stack trace at "+"https://github.com/mscdex/ssh2/issues\n";this.message=e===undefined?t:`${e}\n${t}`}};const s=2**32;const o=(()=>{try{return new Function("return 2n ** 32n")()}catch{}})();t.ERR_OUT_OF_RANGE=class ERR_OUT_OF_RANGE extends RangeError{constructor(e,t,n,f){super();Error.captureStackTrace(this,ERR_OUT_OF_RANGE);i(t,'Missing "range" argument');let h=f?e:`The value of "${e}" is out of range.`;let l;if(Number.isInteger(n)&&Math.abs(n)>s){l=addNumericalSeparator(String(n))}else if(typeof n==="bigint"){l=String(n);if(n>o||n<-o)l=addNumericalSeparator(l);l+="n"}else{l=r(n)}h+=` It must be ${t}. Received ${l}`;this.message=h}};class ERR_INVALID_ARG_TYPE extends TypeError{constructor(e,t,n){super();Error.captureStackTrace(this,ERR_INVALID_ARG_TYPE);i(typeof e==="string",`'name' must be a string`);let r;if(typeof t==="string"&&t.startsWith("not ")){r="must not be";t=t.replace(/^not /,"")}else{r="must be"}let s;if(e.endsWith(" argument")){s=`The ${e} ${r} ${oneOf(t,"type")}`}else{const n=e.includes(".")?"property":"argument";s=`The "${e}" ${n} ${r} ${oneOf(t,"type")}`}s+=`. Received type ${typeof n}`;this.message=s}}t.ERR_INVALID_ARG_TYPE=ERR_INVALID_ARG_TYPE;t.validateNumber=function validateNumber(e,t){if(typeof e!=="number")throw new ERR_INVALID_ARG_TYPE(t,"number",e)}},525:(e,t,n)=>{var i=function(){var e=typeof document!=="undefined"&&document.currentScript?document.currentScript.src:undefined;if(typeof __filename!=="undefined")e=e||__filename;return function(t){t=t||{};var i;i||(i=typeof t!=="undefined"?t:{});var r,s;i.ready=new Promise((function(e,t){r=e;s=t}));var o={},f;for(f in i)i.hasOwnProperty(f)&&(o[f]=i[f]);var h=!1,l=!1,u=!1,A=!1;h="object"===typeof window;l="function"===typeof importScripts;u="object"===typeof process&&"object"===typeof process.versions&&"string"===typeof process.versions.node;A=!h&&!u&&!l;var g="",_,p,E,b,S;if(u)g=l?n(17).dirname(g)+"/":__dirname+"/",_=function(e,t){var i=I(e);if(i)return t?i:i.toString();b||(b=n(147));S||(S=n(17));e=S.normalize(e);return b.readFileSync(e,t?null:"utf8")},E=function(e){e=_(e,!0);e.buffer||(e=new Uint8Array(e));assert(e.buffer);return e},1<process.argv.length&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("unhandledRejection",J),i.inspect=function(){return"[Emscripten Module object]"};else if(A)"undefined"!=typeof read&&(_=function(e){var t=I(e);return t?K(t):read(e)}),E=function(e){var t;if(t=I(e))return t;if("function"===typeof readbuffer)return new Uint8Array(readbuffer(e));t=read(e,"binary");assert("object"===typeof t);return t},"undefined"!==typeof print&&("undefined"===typeof console&&(console={}),console.log=print,console.warn=console.error="undefined"!==typeof printErr?printErr:print);else if(h||l)l?g=self.location.href:"undefined"!==typeof document&&document.currentScript&&(g=document.currentScript.src),e&&(g=e),0!==g.indexOf("blob:")?g=g.substr(0,g.lastIndexOf("/")+1):g="",_=function(e){try{var t=new XMLHttpRequest;t.open("GET",e,!1);t.send(null);return t.responseText}catch(t){if(e=I(e))return K(e);throw t}},l&&(E=function(e){try{var t=new XMLHttpRequest;t.open("GET",e,!1);t.responseType="arraybuffer";t.send(null);return new Uint8Array(t.response)}catch(t){if(e=I(e))return e;throw t}}),p=function(e,t,n){var i=new XMLHttpRequest;i.open("GET",e,!0);i.responseType="arraybuffer";i.onload=function(){if(200==i.status||0==i.status&&i.response)t(i.response);else{var r=I(e);r?t(r.buffer):n()}};i.onerror=n;i.send(null)};i.print||console.log.bind(console);var y=i.printErr||console.warn.bind(console);for(f in o)o.hasOwnProperty(f)&&(i[f]=o[f]);o=null;var m;i.wasmBinary&&(m=i.wasmBinary);var w=i.noExitRuntime||!0;"object"!==typeof WebAssembly&&J("no native wasm support detected");var C,B=!1;function assert(e,t){e||J("Assertion failed: "+t)}function aa(e){var t=i["_"+e];assert(t,"Cannot call unknown function "+e+", make sure it is exported");return t}function ba(e,t,n,i){var r={string:function(e){var t=0;if(null!==e&&void 0!==e&&0!==e){var n=(e.length<<2)+1;t=Y(n);var i=t,r=T;if(0<n){n=i+n-1;for(var s=0;s<e.length;++s){var o=e.charCodeAt(s);if(55296<=o&&57343>=o){var f=e.charCodeAt(++s);o=65536+((o&1023)<<10)|f&1023}if(127>=o){if(i>=n)break;r[i++]=o}else{if(2047>=o){if(i+1>=n)break;r[i++]=192|o>>6}else{if(65535>=o){if(i+2>=n)break;r[i++]=224|o>>12}else{if(i+3>=n)break;r[i++]=240|o>>18;r[i++]=128|o>>12&63}r[i++]=128|o>>6&63}r[i++]=128|o&63}}r[i]=0}}return t},array:function(e){var t=Y(e.length);N.set(e,t);return t}},s=aa(e),o=[];e=0;if(i)for(var f=0;f<i.length;f++){var h=r[n[f]];h?(0===e&&(e=G()),o[f]=h(i[f])):o[f]=i[f]}n=s.apply(null,o);n=function(e){if("string"===t)if(e){for(var n=T,i=e+NaN,r=e;n[r]&&!(r>=i);)++r;if(16<r-e&&n.subarray&&k)e=k.decode(n.subarray(e,r));else{for(i="";e<r;){var s=n[e++];if(s&128){var o=n[e++]&63;if(192==(s&224))i+=String.fromCharCode((s&31)<<6|o);else{var f=n[e++]&63;s=224==(s&240)?(s&15)<<12|o<<6|f:(s&7)<<18|o<<12|f<<6|n[e++]&63;65536>s?i+=String.fromCharCode(s):(s-=65536,i+=String.fromCharCode(55296|s>>10,56320|s&1023))}}else i+=String.fromCharCode(s)}e=i}}else e="";else e="boolean"===t?!!e:e;return e}(n);0!==e&&$(e);return n}var k="undefined"!==typeof TextDecoder?new TextDecoder("utf8"):void 0,R,N,T;function ja(){var e=C.buffer;R=e;i.HEAP8=N=new Int8Array(e);i.HEAP16=new Int16Array(e);i.HEAP32=new Int32Array(e);i.HEAPU8=T=new Uint8Array(e);i.HEAPU16=new Uint16Array(e);i.HEAPU32=new Uint32Array(e);i.HEAPF32=new Float32Array(e);i.HEAPF64=new Float64Array(e)}var P,U=[],Q=[],L=[];function na(){var e=i.preRun.shift();U.unshift(e)}var O=0,D=null,v=null;i.preloadedImages={};i.preloadedAudios={};function J(e){if(i.onAbort)i.onAbort(e);y(e);B=!0;e=new WebAssembly.RuntimeError("abort("+e+"). Build with -s ASSERTIONS=1 for more info.");s(e);throw e}var H="data:application/octet-stream;base64,",F="data:application/octet-stream;base64,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";if(!F.startsWith(H)){var W=F;F=i.locateFile?i.locateFile(W,g):g+W}function qa(){var e=F;try{if(e==F&&m)return new Uint8Array(m);var t=I(e);if(t)return t;if(E)return E(e);throw"both async and sync fetching of the wasm failed"}catch(e){J(e)}}function ra(){if(!m&&(h||l)){if("function"===typeof fetch&&!F.startsWith("file://"))return fetch(F,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+F+"'";return e.arrayBuffer()})).catch((function(){return qa()}));if(p)return new Promise((function(e,t){p(F,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return qa()}))}function X(e){for(;0<e.length;){var t=e.shift();if("function"==typeof t)t(i);else{var n=t.m;"number"===typeof n?void 0===t.l?P.get(n)():P.get(n)(t.l):n(void 0===t.l?null:t.l)}}}var x=!1;function K(e){for(var t=[],n=0;n<e.length;n++){var i=e[n];255<i&&(x&&assert(!1,"Character code "+i+" ("+String.fromCharCode(i)+")  at offset "+n+" not in 0x00-0xFF."),i&=255);t.push(String.fromCharCode(i))}return t.join("")}var M="function"===typeof atob?atob:function(e){var t="",n=0;e=e.replace(/[^A-Za-z0-9\+\/=]/g,"");do{var i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(e.charAt(n++));var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(e.charAt(n++));var s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(e.charAt(n++));var o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(e.charAt(n++));i=i<<2|r>>4;r=(r&15)<<4|s>>2;var f=(s&3)<<6|o;t+=String.fromCharCode(i);64!==s&&(t+=String.fromCharCode(r));64!==o&&(t+=String.fromCharCode(f))}while(n<e.length);return t};function I(e){if(e.startsWith(H)){e=e.slice(H.length);if("boolean"===typeof u&&u){try{var t=Buffer.from(e,"base64")}catch(n){t=new Buffer(e,"base64")}var n=new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}else try{var i=M(e),r=new Uint8Array(i.length);for(t=0;t<i.length;++t)r[t]=i.charCodeAt(t);n=r}catch(e){throw Error("Converting base64 string to bytes failed.")}return n}}var q={a:function(e){var t=T.length;e>>>=0;if(2147483648<e)return!1;for(var n=1;4>=n;n*=2){var i=t*(1+.2/n);i=Math.min(i,e+100663296);i=Math.max(e,i);0<i%65536&&(i+=65536-i%65536);e:{try{C.grow(Math.min(2147483648,i)-R.byteLength+65535>>>16);ja();var r=1;break e}catch(e){}r=void 0}if(r)return!0}return!1}};(function(){function a(e){i.asm=e.exports;C=i.asm.b;ja();P=i.asm.j;Q.unshift(i.asm.c);O--;i.monitorRunDependencies&&i.monitorRunDependencies(O);0==O&&(null!==D&&(clearInterval(D),D=null),v&&(e=v,v=null,e()))}function c(e){a(e.instance)}function d(t){return ra().then((function(t){return WebAssembly.instantiate(t,e)})).then(t,(function(e){y("failed to asynchronously prepare wasm: "+e);J(e)}))}var e={a:q};O++;i.monitorRunDependencies&&i.monitorRunDependencies(O);if(i.instantiateWasm)try{return i.instantiateWasm(e,a)}catch(e){return y("Module.instantiateWasm callback failed with error: "+e),!1}(function(){return m||"function"!==typeof WebAssembly.instantiateStreaming||F.startsWith(H)||F.startsWith("file://")||"function"!==typeof fetch?d(c):fetch(F,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(c,(function(e){y("wasm streaming compile failed: "+e);y("falling back to ArrayBuffer instantiation");return d(c)}))}))})().catch(s);return{}})();i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.c).apply(null,arguments)};i._poly1305_auth=function(){return(i._poly1305_auth=i.asm.d).apply(null,arguments)};var G=i.stackSave=function(){return(G=i.stackSave=i.asm.e).apply(null,arguments)},$=i.stackRestore=function(){return($=i.stackRestore=i.asm.f).apply(null,arguments)},Y=i.stackAlloc=function(){return(Y=i.stackAlloc=i.asm.g).apply(null,arguments)};i._malloc=function(){return(i._malloc=i.asm.h).apply(null,arguments)};i._free=function(){return(i._free=i.asm.i).apply(null,arguments)};i.cwrap=function(e,t,n,i){n=n||[];var r=n.every((function(e){return"number"===e}));return"string"!==t&&r&&!i?aa(e):function(){return ba(e,t,n,arguments)}};var j;v=function va(){j||Z();j||(v=va)};function Z(){function a(){if(!j&&(j=!0,i.calledRun=!0,!B)){X(Q);r(i);if(i.onRuntimeInitialized)i.onRuntimeInitialized();if(i.postRun)for("function"==typeof i.postRun&&(i.postRun=[i.postRun]);i.postRun.length;){var e=i.postRun.shift();L.unshift(e)}X(L)}}if(!(0<O)){if(i.preRun)for("function"==typeof i.preRun&&(i.preRun=[i.preRun]);i.preRun.length;)na();X(U);0<O||(i.setStatus?(i.setStatus("Running..."),setTimeout((function(){setTimeout((function(){i.setStatus("")}),1);a()}),1)):a())}}i.run=Z;if(i.preInit)for("function"==typeof i.preInit&&(i.preInit=[i.preInit]);0<i.preInit.length;)i.preInit.pop()();Z();return t.ready}}();if(true)e.exports=i;else{}},290:(e,t,n)=>{const{inspect:i}=n(837);const{bindingAvailable:r,NullCipher:s,NullDecipher:o}=n(298);const{COMPAT_CHECKS:f,DISCONNECT_REASON:h,MESSAGE:l,SIGNALS:u,TERMINAL_MODE:A}=n(434);const{DEFAULT_KEXINIT:g,KexInit:_,kexinit:p,onKEXPayload:E}=n(352);const{parseKey:b}=n(887);const S=n(958);const{bufferCopy:y,bufferFill:m,bufferSlice:w,convertSignature:C,sendPacket:B,writeUInt32BE:k}=n(223);const{PacketReader:R,PacketWriter:N,ZlibPacketReader:T,ZlibPacketWriter:P}=n(983);const U=new Map(Object.values(h).map((e=>[e,1])));const Q=Buffer.from("SSH-2.0-PPP");const L=Buffer.from(`${Q}\r\n`);const O=8192;const D=1024;const v=Buffer.from([l.GLOBAL_REQUEST,0,0,0,21,107,101,101,112,97,108,105,118,101,64,111,112,101,110,115,115,104,46,99,111,109,1]);const H=Buffer.from([A.TTY_OP_END]);function noop(){}class Protocol{constructor(e){const t=e.onWrite;if(typeof t!=="function")throw new Error("Missing onWrite function");this._onWrite=e=>{t(e)};const n=e.onError;if(typeof n!=="function")throw new Error("Missing onError function");this._onError=e=>{n(e)};const o=e.debug;this._debug=typeof o==="function"?e=>{o(e)}:undefined;const f=e.onHeader;this._onHeader=typeof f==="function"?(...e)=>{f(...e)}:noop;const h=e.onPacket;this._onPacket=typeof h==="function"?()=>{h()}:noop;let l=e.onHandshakeComplete;if(typeof l!=="function")l=noop;this._onHandshakeComplete=(...e)=>{this._debug&&this._debug("Handshake completed");const t=this._queue;if(t){this._queue=undefined;this._debug&&this._debug(`Draining outbound queue (${t.length}) ...`);for(let e=0;e<t.length;++e){const n=t[e];let i=this._packetRW.write.finalize(n);if(i===n){const e=this._cipher.allocPacket(n.length);e.set(n,5);i=e}B(this,i)}this._debug&&this._debug("... finished draining outbound queue")}l(...e)};this._queue=undefined;const u=e.messageHandlers;if(typeof u==="object"&&u!==null)this._handlers=u;else this._handlers={};this._onPayload=onPayload.bind(this);this._server=!!e.server;this._banner=undefined;let A;if(this._server){if(typeof e.hostKeys!=="object"||e.hostKeys===null)throw new Error("Missing server host key(s)");this._hostKeys=e.hostKeys;if(typeof e.greeting==="string"&&e.greeting.length){A=e.greeting.slice(-2)==="\r\n"?e.greeting:`${e.greeting}\r\n`}if(typeof e.banner==="string"&&e.banner.length){this._banner=e.banner.slice(-2)==="\r\n"?e.banner:`${e.banner}\r\n`}}else{this._hostKeys=undefined}let p=e.offer;if(typeof p!=="object"||p===null)p=g;else if(p.constructor!==_)p=new _(p);this._kex=undefined;this._kexinit=undefined;this._offer=p;this._cipher=new s(0,this._onWrite);this._decipher=undefined;this._skipNextInboundPacket=false;this._packetRW={read:new R,write:new N(this)};this._hostVerifier=!this._server&&typeof e.hostVerifier==="function"?e.hostVerifier:undefined;this._parse=parseHeader;this._buffer=undefined;this._authsQueue=[];this._authenticated=false;this._remoteIdentRaw=undefined;let E;if(typeof e.ident==="string"){this._identRaw=Buffer.from(`SSH-2.0-${e.ident}`);E=Buffer.allocUnsafe(this._identRaw.length+2);E.set(this._identRaw,0);E[E.length-2]=13;E[E.length-1]=10}else if(Buffer.isBuffer(e.ident)){const t=Buffer.allocUnsafe(8+e.ident.length);t.latin1Write("SSH-2.0-",0,8);t.set(e.ident,8);this._identRaw=t;E=Buffer.allocUnsafe(t.length+2);E.set(t,0);E[E.length-2]=13;E[E.length-1]=10}else{this._identRaw=Q;E=L}this._compatFlags=0;if(this._debug){if(r)this._debug("Custom crypto binding available");else this._debug("Custom crypto binding not available")}process.nextTick((()=>{this._debug&&this._debug(`Local ident: ${i(this._identRaw.toString())}`);if(A)this._onWrite(A);this._onWrite(E)}))}_destruct(e){this._packetRW.read.cleanup();this._packetRW.write.cleanup();this._cipher&&this._cipher.free();this._decipher&&this._decipher.free();if(typeof e!=="string"||e.length===0)e="fatal error";this.parse=()=>{throw new Error(`Instance unusable after ${e}`)};this._onWrite=()=>{throw new Error(`Instance unusable after ${e}`)};this._destruct=undefined}cleanup(){this._destruct&&this._destruct()}parse(e,t,n){while(t<n)t=this._parse(e,t,n)}disconnect(e){const t=1+4+4+4;let n=this._packetRW.write.allocStartKEX;const i=this._packetRW.write.alloc(t,true);const r=n+t;if(!U.has(e))e=h.PROTOCOL_ERROR;i[n]=l.DISCONNECT;k(i,e,++n);i.fill(0,n+=4,r);this._debug&&this._debug(`Outbound: Sending DISCONNECT (${e})`);B(this,this._packetRW.write.finalize(i,true),true)}ping(){const e=this._packetRW.write.allocStart;const t=this._packetRW.write.alloc(v.length);t.set(v,e);this._debug&&this._debug("Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)");B(this,this._packetRW.write.finalize(t))}rekey(){if(this._kexinit===undefined){this._debug&&this._debug("Outbound: Initiated explicit rekey");this._queue=[];p(this)}else{this._debug&&this._debug("Outbound: Ignoring rekey during handshake")}}requestSuccess(e){let t=this._packetRW.write.allocStart;let n;if(Buffer.isBuffer(e)){n=this._packetRW.write.alloc(1+e.length);n[t]=l.REQUEST_SUCCESS;n.set(e,++t)}else{n=this._packetRW.write.alloc(1);n[t]=l.REQUEST_SUCCESS}this._debug&&this._debug("Outbound: Sending REQUEST_SUCCESS");B(this,this._packetRW.write.finalize(n))}requestFailure(){const e=this._packetRW.write.allocStart;const t=this._packetRW.write.alloc(1);t[e]=l.REQUEST_FAILURE;this._debug&&this._debug("Outbound: Sending REQUEST_FAILURE");B(this,this._packetRW.write.finalize(t))}channelSuccess(e){let t=this._packetRW.write.allocStart;const n=this._packetRW.write.alloc(1+4);n[t]=l.CHANNEL_SUCCESS;k(n,e,++t);this._debug&&this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${e})`);B(this,this._packetRW.write.finalize(n))}channelFailure(e){let t=this._packetRW.write.allocStart;const n=this._packetRW.write.alloc(1+4);n[t]=l.CHANNEL_FAILURE;k(n,e,++t);this._debug&&this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${e})`);B(this,this._packetRW.write.finalize(n))}channelEOF(e){let t=this._packetRW.write.allocStart;const n=this._packetRW.write.alloc(1+4);n[t]=l.CHANNEL_EOF;k(n,e,++t);this._debug&&this._debug(`Outbound: Sending CHANNEL_EOF (r:${e})`);B(this,this._packetRW.write.finalize(n))}channelClose(e){let t=this._packetRW.write.allocStart;const n=this._packetRW.write.alloc(1+4);n[t]=l.CHANNEL_CLOSE;k(n,e,++t);this._debug&&this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${e})`);B(this,this._packetRW.write.finalize(n))}channelWindowAdjust(e,t){let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+4);i[n]=l.CHANNEL_WINDOW_ADJUST;k(i,e,++n);k(i,t,n+=4);this._debug&&this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${e}, ${t})`);B(this,this._packetRW.write.finalize(i))}channelData(e,t){const n=Buffer.isBuffer(t);const i=n?t.length:Buffer.byteLength(t);let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+4+i);s[r]=l.CHANNEL_DATA;k(s,e,++r);k(s,i,r+=4);if(n)s.set(t,r+=4);else s.utf8Write(t,r+=4,i);this._debug&&this._debug(`Outbound: Sending CHANNEL_DATA (r:${e}, ${i})`);B(this,this._packetRW.write.finalize(s))}channelExtData(e,t,n){const i=Buffer.isBuffer(t);const r=i?t.length:Buffer.byteLength(t);let s=this._packetRW.write.allocStart;const o=this._packetRW.write.alloc(1+4+4+4+r);o[s]=l.CHANNEL_EXTENDED_DATA;k(o,e,++s);k(o,n,s+=4);k(o,r,s+=4);if(i)o.set(t,s+=4);else o.utf8Write(t,s+=4,r);this._debug&&this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${e})`);B(this,this._packetRW.write.finalize(o))}channelOpenConfirm(e,t,n,i){let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+4+4+4);s[r]=l.CHANNEL_OPEN_CONFIRMATION;k(s,e,++r);k(s,t,r+=4);k(s,n,r+=4);k(s,i,r+=4);this._debug&&this._debug(`Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${e}, l:${t})`);B(this,this._packetRW.write.finalize(s))}channelOpenFail(e,t,n){if(typeof n!=="string")n="";const i=Buffer.byteLength(n);let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+4+4+i+4);s[r]=l.CHANNEL_OPEN_FAILURE;k(s,e,++r);k(s,t,r+=4);k(s,i,r+=4);r+=4;if(i){s.utf8Write(n,r,i);r+=i}k(s,0,r);this._debug&&this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${e})`);B(this,this._packetRW.write.finalize(s))}service(e){if(this._server)throw new Error("Client-only method called in server mode");const t=Buffer.byteLength(e);let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+t);i[n]=l.SERVICE_REQUEST;k(i,t,++n);i.utf8Write(e,n+=4,t);this._debug&&this._debug(`Outbound: Sending SERVICE_REQUEST (${e})`);B(this,this._packetRW.write.finalize(i))}authPassword(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");const i=Buffer.byteLength(e);const r=Buffer.byteLength(t);const s=n?Buffer.byteLength(n):0;let o=this._packetRW.write.allocStart;const f=this._packetRW.write.alloc(1+4+i+4+14+4+8+1+4+r+(n?4+s:0));f[o]=l.USERAUTH_REQUEST;k(f,i,++o);f.utf8Write(e,o+=4,i);k(f,14,o+=i);f.utf8Write("ssh-connection",o+=4,14);k(f,8,o+=14);f.utf8Write("password",o+=4,8);f[o+=8]=n?1:0;k(f,r,++o);if(Buffer.isBuffer(t))y(t,f,0,r,o+=4);else f.utf8Write(t,o+=4,r);if(n){k(f,s,o+=r);if(Buffer.isBuffer(n))y(n,f,0,s,o+=4);else f.utf8Write(n,o+=4,s);this._debug&&this._debug("Outbound: Sending USERAUTH_REQUEST (changed password)")}else{this._debug&&this._debug("Outbound: Sending USERAUTH_REQUEST (password)")}this._authsQueue.push("password");B(this,this._packetRW.write.finalize(f))}authPK(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");t=b(t);if(t instanceof Error)throw new Error("Invalid key");const i=t.type;t=t.getPublicSSH();const r=Buffer.byteLength(e);const s=Buffer.byteLength(i);const o=t.length;const f=this._kex.sessionID;const h=f.length;const u=(n?4+h:0)+1+4+r+4+14+4+9+1+4+s+4+o;let A;let g;if(n){A=Buffer.allocUnsafe(u);g=0;k(A,h,g);A.set(f,g+=4);g+=h}else{A=this._packetRW.write.alloc(u);g=this._packetRW.write.allocStart}A[g]=l.USERAUTH_REQUEST;k(A,r,++g);A.utf8Write(e,g+=4,r);k(A,14,g+=r);A.utf8Write("ssh-connection",g+=4,14);k(A,9,g+=14);A.utf8Write("publickey",g+=4,9);A[g+=9]=n?1:0;k(A,s,++g);A.utf8Write(i,g+=4,s);k(A,o,g+=s);A.set(t,g+=4);if(!n){this._authsQueue.push("publickey");this._debug&&this._debug("Outbound: Sending USERAUTH_REQUEST (publickey -- check)");B(this,this._packetRW.write.finalize(A));return}n(A,(n=>{n=C(n,i);if(n===false)throw new Error("Error while converting handshake signature");const f=n.length;g=this._packetRW.write.allocStart;A=this._packetRW.write.alloc(1+4+r+4+14+4+9+1+4+s+4+o+4+4+s+4+f);A[g]=l.USERAUTH_REQUEST;k(A,r,++g);A.utf8Write(e,g+=4,r);k(A,14,g+=r);A.utf8Write("ssh-connection",g+=4,14);k(A,9,g+=14);A.utf8Write("publickey",g+=4,9);A[g+=9]=1;k(A,s,++g);A.utf8Write(i,g+=4,s);k(A,o,g+=s);A.set(t,g+=4);k(A,4+s+4+f,g+=o);k(A,s,g+=4);A.utf8Write(i,g+=4,s);k(A,f,g+=s);A.set(n,g+=4);this._authsQueue.push("publickey");this._debug&&this._debug("Outbound: Sending USERAUTH_REQUEST (publickey)");B(this,this._packetRW.write.finalize(A))}))}authHostbased(e,t,n,i,r){if(this._server)throw new Error("Client-only method called in server mode");t=b(t);if(t instanceof Error)throw new Error("Invalid key");const s=t.type;t=t.getPublicSSH();const o=Buffer.byteLength(e);const f=Buffer.byteLength(s);const h=t.length;const u=this._kex.sessionID;const A=u.length;const g=Buffer.byteLength(n);const _=Buffer.byteLength(i);const p=Buffer.allocUnsafe(4+A+1+4+o+4+14+4+9+4+f+4+h+4+g+4+_);let E=0;k(p,A,E);p.set(u,E+=4);p[E+=A]=l.USERAUTH_REQUEST;k(p,o,++E);p.utf8Write(e,E+=4,o);k(p,14,E+=o);p.utf8Write("ssh-connection",E+=4,14);k(p,9,E+=14);p.utf8Write("hostbased",E+=4,9);k(p,f,E+=9);p.utf8Write(s,E+=4,f);k(p,h,E+=f);p.set(t,E+=4);k(p,g,E+=h);p.utf8Write(n,E+=4,g);k(p,_,E+=g);p.utf8Write(i,E+=4,_);r(p,(e=>{e=C(e,s);if(!e)throw new Error("Error while converting handshake signature");const t=e.length;const n=p.length-A-4;E=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(n+4+4+f+4+t);y(p,i,4+A,p.length,E);k(i,4+f+4+t,E+=n);k(i,f,E+=4);i.utf8Write(s,E+=4,f);k(i,t,E+=f);i.set(e,E+=4);this._authsQueue.push("hostbased");this._debug&&this._debug("Outbound: Sending USERAUTH_REQUEST (hostbased)");B(this,this._packetRW.write.finalize(i))}))}authKeyboard(e){if(this._server)throw new Error("Client-only method called in server mode");const t=Buffer.byteLength(e);let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+t+4+14+4+20+4+4);i[n]=l.USERAUTH_REQUEST;k(i,t,++n);i.utf8Write(e,n+=4,t);k(i,14,n+=t);i.utf8Write("ssh-connection",n+=4,14);k(i,20,n+=14);i.utf8Write("keyboard-interactive",n+=4,20);k(i,0,n+=20);k(i,0,n+=4);this._authsQueue.push("keyboard-interactive");this._debug&&this._debug("Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)");B(this,this._packetRW.write.finalize(i))}authNone(e){if(this._server)throw new Error("Client-only method called in server mode");const t=Buffer.byteLength(e);let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+t+4+14+4+4);i[n]=l.USERAUTH_REQUEST;k(i,t,++n);i.utf8Write(e,n+=4,t);k(i,14,n+=t);i.utf8Write("ssh-connection",n+=4,14);k(i,4,n+=14);i.utf8Write("none",n+=4,4);this._authsQueue.push("none");this._debug&&this._debug("Outbound: Sending USERAUTH_REQUEST (none)");B(this,this._packetRW.write.finalize(i))}authInfoRes(e){if(this._server)throw new Error("Client-only method called in server mode");let t=0;let n;if(e){n=new Array(e.length);for(let i=0;i<e.length;++i){const r=Buffer.byteLength(e[i]);n[i]=r;t+=4+r}}let i=this._packetRW.write.allocStart;const r=this._packetRW.write.alloc(1+4+t);r[i]=l.USERAUTH_INFO_RESPONSE;if(e){k(r,e.length,++i);i+=4;for(let t=0;t<e.length;++t){const s=n[t];k(r,s,i);i+=4;if(s){r.utf8Write(e[t],i,s);i+=s}}}else{k(r,0,++i)}this._debug&&this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE");B(this,this._packetRW.write.finalize(r))}tcpipForward(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");const i=Buffer.byteLength(e);let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+13+1+4+i+4);s[r]=l.GLOBAL_REQUEST;k(s,13,++r);s.utf8Write("tcpip-forward",r+=4,13);s[r+=13]=n===undefined||n===true?1:0;k(s,i,++r);s.utf8Write(e,r+=4,i);k(s,t,r+=i);this._debug&&this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)");B(this,this._packetRW.write.finalize(s))}cancelTcpipForward(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");const i=Buffer.byteLength(e);let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+20+1+4+i+4);s[r]=l.GLOBAL_REQUEST;k(s,20,++r);s.utf8Write("cancel-tcpip-forward",r+=4,20);s[r+=20]=n===undefined||n===true?1:0;k(s,i,++r);s.utf8Write(e,r+=4,i);k(s,t,r+=i);this._debug&&this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)");B(this,this._packetRW.write.finalize(s))}openssh_streamLocalForward(e,t){if(this._server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=this._packetRW.write.allocStart;const r=this._packetRW.write.alloc(1+4+31+1+4+n);r[i]=l.GLOBAL_REQUEST;k(r,31,++i);r.utf8Write("streamlocal-forward@openssh.com",i+=4,31);r[i+=31]=t===undefined||t===true?1:0;k(r,n,++i);r.utf8Write(e,i+=4,n);this._debug&&this._debug("Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)");B(this,this._packetRW.write.finalize(r))}openssh_cancelStreamLocalForward(e,t){if(this._server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=this._packetRW.write.allocStart;const r=this._packetRW.write.alloc(1+4+38+1+4+n);r[i]=l.GLOBAL_REQUEST;k(r,38,++i);r.utf8Write("cancel-streamlocal-forward@openssh.com",i+=4,38);r[i+=38]=t===undefined||t===true?1:0;k(r,n,++i);r.utf8Write(e,i+=4,n);if(this._debug){this._debug("Outbound: Sending GLOBAL_REQUEST "+"(cancel-streamlocal-forward@openssh.com)")}B(this,this._packetRW.write.finalize(r))}directTcpip(e,t,n,i){if(this._server)throw new Error("Client-only method called in server mode");const r=Buffer.byteLength(i.srcIP);const s=Buffer.byteLength(i.dstIP);let o=this._packetRW.write.allocStart;const f=this._packetRW.write.alloc(1+4+12+4+4+4+4+r+4+4+s+4);f[o]=l.CHANNEL_OPEN;k(f,12,++o);f.utf8Write("direct-tcpip",o+=4,12);k(f,e,o+=12);k(f,t,o+=4);k(f,n,o+=4);k(f,s,o+=4);f.utf8Write(i.dstIP,o+=4,s);k(f,i.dstPort,o+=s);k(f,r,o+=4);f.utf8Write(i.srcIP,o+=4,r);k(f,i.srcPort,o+=r);this._debug&&this._debug(`Outbound: Sending CHANNEL_OPEN (r:${e}, direct-tcpip)`);B(this,this._packetRW.write.finalize(f))}openssh_directStreamLocal(e,t,n,i){if(this._server)throw new Error("Client-only method called in server mode");const r=Buffer.byteLength(i.socketPath);let s=this._packetRW.write.allocStart;const o=this._packetRW.write.alloc(1+4+30+4+4+4+4+r+4+4);o[s]=l.CHANNEL_OPEN;k(o,30,++s);o.utf8Write("direct-streamlocal@openssh.com",s+=4,30);k(o,e,s+=30);k(o,t,s+=4);k(o,n,s+=4);k(o,r,s+=4);o.utf8Write(i.socketPath,s+=4,r);m(o,0,s+=r,s+8);if(this._debug){this._debug("Outbound: Sending CHANNEL_OPEN "+`(r:${e}, direct-streamlocal@openssh.com)`)}B(this,this._packetRW.write.finalize(o))}openssh_noMoreSessions(e){if(this._server)throw new Error("Client-only method called in server mode");let t=this._packetRW.write.allocStart;const n=this._packetRW.write.alloc(1+4+28+1);n[t]=l.GLOBAL_REQUEST;k(n,28,++t);n.utf8Write("no-more-sessions@openssh.com",t+=4,28);n[t+=28]=e===undefined||e===true?1:0;this._debug&&this._debug("Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)");B(this,this._packetRW.write.finalize(n))}session(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");let i=this._packetRW.write.allocStart;const r=this._packetRW.write.alloc(1+4+7+4+4+4);r[i]=l.CHANNEL_OPEN;k(r,7,++i);r.utf8Write("session",i+=4,7);k(r,e,i+=7);k(r,t,i+=4);k(r,n,i+=4);this._debug&&this._debug(`Outbound: Sending CHANNEL_OPEN (r:${e}, session)`);B(this,this._packetRW.write.finalize(r))}windowChange(e,t,n,i,r){if(this._server)throw new Error("Client-only method called in server mode");let s=this._packetRW.write.allocStart;const o=this._packetRW.write.alloc(1+4+4+13+1+4+4+4+4);o[s]=l.CHANNEL_REQUEST;k(o,e,++s);k(o,13,s+=4);o.utf8Write("window-change",s+=4,13);o[s+=13]=0;k(o,n,++s);k(o,t,s+=4);k(o,r,s+=4);k(o,i,s+=4);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, window-change)`);B(this,this._packetRW.write.finalize(o))}pty(e,t,n,i,r,s,o,f){if(this._server)throw new Error("Client-only method called in server mode");if(!s||!s.length)s="vt100";if(o&&!Buffer.isBuffer(o)&&!Array.isArray(o)&&typeof o==="object"&&o!==null){o=modesToBytes(o)}if(!o||!o.length)o=H;const h=s.length;const u=o.length;let A=this._packetRW.write.allocStart;const g=this._packetRW.write.alloc(1+4+4+7+1+4+h+4+4+4+4+4+u);g[A]=l.CHANNEL_REQUEST;k(g,e,++A);k(g,7,A+=4);g.utf8Write("pty-req",A+=4,7);g[A+=7]=f===undefined||f===true?1:0;k(g,h,++A);g.utf8Write(s,A+=4,h);k(g,n,A+=h);k(g,t,A+=4);k(g,r,A+=4);k(g,i,A+=4);k(g,u,A+=4);A+=4;if(Array.isArray(o)){for(let e=0;e<u;++e)g[A++]=o[e]}else if(Buffer.isBuffer(o)){g.set(o,A)}this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, pty-req)`);B(this,this._packetRW.write.finalize(g))}shell(e,t){if(this._server)throw new Error("Client-only method called in server mode");let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+4+5+1);i[n]=l.CHANNEL_REQUEST;k(i,e,++n);k(i,5,n+=4);i.utf8Write("shell",n+=4,5);i[n+=5]=t===undefined||t===true?1:0;this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, shell)`);B(this,this._packetRW.write.finalize(i))}exec(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");const i=Buffer.isBuffer(t);const r=i?t.length:Buffer.byteLength(t);let s=this._packetRW.write.allocStart;const o=this._packetRW.write.alloc(1+4+4+4+1+4+r);o[s]=l.CHANNEL_REQUEST;k(o,e,++s);k(o,4,s+=4);o.utf8Write("exec",s+=4,4);o[s+=4]=n===undefined||n===true?1:0;k(o,r,++s);if(i)o.set(t,s+=4);else o.utf8Write(t,s+=4,r);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, exec: ${t})`);B(this,this._packetRW.write.finalize(o))}signal(e,t){if(this._server)throw new Error("Client-only method called in server mode");const n=t;t=t.toUpperCase();if(t.slice(0,3)==="SIG")t=t.slice(3);if(u[t]!==1)throw new Error(`Invalid signal: ${n}`);const i=t.length;let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+4+6+1+4+i);s[r]=l.CHANNEL_REQUEST;k(s,e,++r);k(s,6,r+=4);s.utf8Write("signal",r+=4,6);s[r+=6]=0;k(s,i,++r);s.utf8Write(t,r+=4,i);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, signal: ${t})`);B(this,this._packetRW.write.finalize(s))}env(e,t,n,i){if(this._server)throw new Error("Client-only method called in server mode");const r=Buffer.byteLength(t);const s=Buffer.isBuffer(n);const o=s?n.length:Buffer.byteLength(n);let f=this._packetRW.write.allocStart;const h=this._packetRW.write.alloc(1+4+4+3+1+4+r+4+o);h[f]=l.CHANNEL_REQUEST;k(h,e,++f);k(h,3,f+=4);h.utf8Write("env",f+=4,3);h[f+=3]=i===undefined||i===true?1:0;k(h,r,++f);h.utf8Write(t,f+=4,r);k(h,o,f+=r);if(s)h.set(n,f+=4);else h.utf8Write(n,f+=4,o);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, env: ${t}=${n})`);B(this,this._packetRW.write.finalize(h))}x11Forward(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");const i=t.protocol;const r=t.cookie;const s=Buffer.isBuffer(i);const o=s?i.length:Buffer.byteLength(i);const f=Buffer.isBuffer(r);const h=f?r.length:Buffer.byteLength(r);let u=this._packetRW.write.allocStart;const A=this._packetRW.write.alloc(1+4+4+7+1+1+4+o+4+h+4);A[u]=l.CHANNEL_REQUEST;k(A,e,++u);k(A,7,u+=4);A.utf8Write("x11-req",u+=4,7);A[u+=7]=n===undefined||n===true?1:0;A[++u]=t.single?1:0;k(A,o,++u);if(s)A.set(i,u+=4);else A.utf8Write(i,u+=4,o);k(A,h,u+=o);if(f)A.set(r,u+=4);else A.latin1Write(r,u+=4,h);k(A,t.screen||0,u+=h);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, x11-req)`);B(this,this._packetRW.write.finalize(A))}subsystem(e,t,n){if(this._server)throw new Error("Client-only method called in server mode");const i=Buffer.byteLength(t);let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+4+9+1+4+i);s[r]=l.CHANNEL_REQUEST;k(s,e,++r);k(s,9,r+=4);s.utf8Write("subsystem",r+=4,9);s[r+=9]=n===undefined||n===true?1:0;k(s,i,++r);s.utf8Write(t,r+=4,i);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, subsystem: ${t})`);B(this,this._packetRW.write.finalize(s))}openssh_agentForward(e,t){if(this._server)throw new Error("Client-only method called in server mode");let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+4+26+1);i[n]=l.CHANNEL_REQUEST;k(i,e,++n);k(i,26,n+=4);i.utf8Write("auth-agent-req@openssh.com",n+=4,26);i[n+=26]=t===undefined||t===true?1:0;if(this._debug){this._debug("Outbound: Sending CHANNEL_REQUEST "+`(r:${e}, auth-agent-req@openssh.com)`)}B(this,this._packetRW.write.finalize(i))}openssh_hostKeysProve(e){if(this._server)throw new Error("Client-only method called in server mode");let t=0;const n=[];for(const i of e){const e=i.getPublicSSH();t+=4+e.length;n.push(e)}let i=this._packetRW.write.allocStart;const r=this._packetRW.write.alloc(1+4+29+1+t);r[i]=l.GLOBAL_REQUEST;k(r,29,++i);r.utf8Write("hostkeys-prove-00@openssh.com",i+=4,29);r[i+=29]=1;++i;for(const e of n){k(r,e.length,i);y(e,r,0,e.length,i+=4);i+=e.length}if(this._debug){this._debug("Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)")}B(this,this._packetRW.write.finalize(r))}serviceAccept(e){if(!this._server)throw new Error("Server-only method called in client mode");const t=Buffer.byteLength(e);let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+t);i[n]=l.SERVICE_ACCEPT;k(i,t,++n);i.utf8Write(e,n+=4,t);this._debug&&this._debug(`Outbound: Sending SERVICE_ACCEPT (${e})`);B(this,this._packetRW.write.finalize(i));if(this._server&&this._banner&&e==="ssh-userauth"){const e=this._banner;this._banner=undefined;const t=Buffer.byteLength(e);n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+t+4);i[n]=l.USERAUTH_BANNER;k(i,t,++n);i.utf8Write(e,n+=4,t);k(i,0,n+=t);this._debug&&this._debug("Outbound: Sending USERAUTH_BANNER");B(this,this._packetRW.write.finalize(i))}}forwardedTcpip(e,t,n,i){if(!this._server)throw new Error("Server-only method called in client mode");const r=Buffer.byteLength(i.boundAddr);const s=Buffer.byteLength(i.remoteAddr);let o=this._packetRW.write.allocStart;const f=this._packetRW.write.alloc(1+4+15+4+4+4+4+r+4+4+s+4);f[o]=l.CHANNEL_OPEN;k(f,15,++o);f.utf8Write("forwarded-tcpip",o+=4,15);k(f,e,o+=15);k(f,t,o+=4);k(f,n,o+=4);k(f,r,o+=4);f.utf8Write(i.boundAddr,o+=4,r);k(f,i.boundPort,o+=r);k(f,s,o+=4);f.utf8Write(i.remoteAddr,o+=4,s);k(f,i.remotePort,o+=s);this._debug&&this._debug(`Outbound: Sending CHANNEL_OPEN (r:${e}, forwarded-tcpip)`);B(this,this._packetRW.write.finalize(f))}x11(e,t,n,i){if(!this._server)throw new Error("Server-only method called in client mode");const r=Buffer.byteLength(i.originAddr);let s=this._packetRW.write.allocStart;const o=this._packetRW.write.alloc(1+4+3+4+4+4+4+r+4);o[s]=l.CHANNEL_OPEN;k(o,3,++s);o.utf8Write("x11",s+=4,3);k(o,e,s+=3);k(o,t,s+=4);k(o,n,s+=4);k(o,r,s+=4);o.utf8Write(i.originAddr,s+=4,r);k(o,i.originPort,s+=r);this._debug&&this._debug(`Outbound: Sending CHANNEL_OPEN (r:${e}, x11)`);B(this,this._packetRW.write.finalize(o))}openssh_authAgent(e,t,n){if(!this._server)throw new Error("Server-only method called in client mode");let i=this._packetRW.write.allocStart;const r=this._packetRW.write.alloc(1+4+22+4+4+4);r[i]=l.CHANNEL_OPEN;k(r,22,++i);r.utf8Write("auth-agent@openssh.com",i+=4,22);k(r,e,i+=22);k(r,t,i+=4);k(r,n,i+=4);this._debug&&this._debug(`Outbound: Sending CHANNEL_OPEN (r:${e}, auth-agent@openssh.com)`);B(this,this._packetRW.write.finalize(r))}openssh_forwardedStreamLocal(e,t,n,i){if(!this._server)throw new Error("Server-only method called in client mode");const r=Buffer.byteLength(i.socketPath);let s=this._packetRW.write.allocStart;const o=this._packetRW.write.alloc(1+4+33+4+4+4+4+r+4);o[s]=l.CHANNEL_OPEN;k(o,33,++s);o.utf8Write("forwarded-streamlocal@openssh.com",s+=4,33);k(o,e,s+=33);k(o,t,s+=4);k(o,n,s+=4);k(o,r,s+=4);o.utf8Write(i.socketPath,s+=4,r);k(o,0,s+=r);if(this._debug){this._debug("Outbound: Sending CHANNEL_OPEN "+`(r:${e}, forwarded-streamlocal@openssh.com)`)}B(this,this._packetRW.write.finalize(o))}exitStatus(e,t){if(!this._server)throw new Error("Server-only method called in client mode");let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+4+11+1+4);i[n]=l.CHANNEL_REQUEST;k(i,e,++n);k(i,11,n+=4);i.utf8Write("exit-status",n+=4,11);i[n+=11]=0;k(i,t,++n);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, exit-status: ${t})`);B(this,this._packetRW.write.finalize(i))}exitSignal(e,t,n,i){if(!this._server)throw new Error("Server-only method called in client mode");const r=t;if(typeof r!=="string"||!r)throw new Error(`Invalid signal: ${r}`);let s=t.toUpperCase();if(s.slice(0,3)==="SIG")s=s.slice(3);if(u[s]!==1)throw new Error(`Invalid signal: ${r}`);const o=Buffer.byteLength(s);const f=i?Buffer.byteLength(i):0;let h=this._packetRW.write.allocStart;const A=this._packetRW.write.alloc(1+4+4+11+1+4+o+1+4+f+4);A[h]=l.CHANNEL_REQUEST;k(A,e,++h);k(A,11,h+=4);A.utf8Write("exit-signal",h+=4,11);A[h+=11]=0;k(A,o,++h);A.utf8Write(s,h+=4,o);A[h+=o]=n?1:0;k(A,f,++h);h+=4;if(f){A.utf8Write(i,h,f);h+=f}k(A,0,h);this._debug&&this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${e}, exit-signal: ${t})`);B(this,this._packetRW.write.finalize(A))}authFailure(e,t){if(!this._server)throw new Error("Server-only method called in client mode");if(this._authsQueue.length===0)throw new Error("No auth in progress");let n;if(typeof e==="boolean"){t=e;e=undefined}if(e){n=[];for(let t=0;t<e.length;++t){if(e[t].toLowerCase()==="none")continue;n.push(e[t])}n=n.join(",")}else{n=""}const i=n.length;let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+i+1);s[r]=l.USERAUTH_FAILURE;k(s,i,++r);s.utf8Write(n,r+=4,i);s[r+=i]=t===true?1:0;this._authsQueue.shift();this._debug&&this._debug("Outbound: Sending USERAUTH_FAILURE");B(this,this._packetRW.write.finalize(s))}authSuccess(){if(!this._server)throw new Error("Server-only method called in client mode");if(this._authsQueue.length===0)throw new Error("No auth in progress");const e=this._packetRW.write.allocStart;const t=this._packetRW.write.alloc(1);t[e]=l.USERAUTH_SUCCESS;this._authsQueue.shift();this._authenticated=true;this._debug&&this._debug("Outbound: Sending USERAUTH_SUCCESS");B(this,this._packetRW.write.finalize(t));if(this._kex.negotiated.cs.compress==="zlib@openssh.com")this._packetRW.read=new T;if(this._kex.negotiated.sc.compress==="zlib@openssh.com")this._packetRW.write=new P(this)}authPKOK(e,t){if(!this._server)throw new Error("Server-only method called in client mode");if(this._authsQueue.length===0||this._authsQueue[0]!=="publickey")throw new Error('"publickey" auth not in progress');const n=Buffer.byteLength(e);const i=t.length;let r=this._packetRW.write.allocStart;const s=this._packetRW.write.alloc(1+4+n+4+i);s[r]=l.USERAUTH_PK_OK;k(s,n,++r);s.utf8Write(e,r+=4,n);k(s,i,r+=n);s.set(t,r+=4);this._authsQueue.shift();this._debug&&this._debug("Outbound: Sending USERAUTH_PK_OK");B(this,this._packetRW.write.finalize(s))}authPasswdChg(e){if(!this._server)throw new Error("Server-only method called in client mode");const t=Buffer.byteLength(e);let n=this._packetRW.write.allocStart;const i=this._packetRW.write.alloc(1+4+t+4);i[n]=l.USERAUTH_PASSWD_CHANGEREQ;k(i,t,++n);i.utf8Write(e,n+=4,t);k(i,0,n+=t);this._debug&&this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ");B(this,this._packetRW.write.finalize(i))}authInfoReq(e,t,n){if(!this._server)throw new Error("Server-only method called in client mode");let i=0;const r=e?Buffer.byteLength(e):0;const s=t?Buffer.byteLength(t):0;for(let e=0;e<n.length;++e)i+=4+Buffer.byteLength(n[e].prompt)+1;let o=this._packetRW.write.allocStart;const f=this._packetRW.write.alloc(1+4+r+4+s+4+4+i);f[o]=l.USERAUTH_INFO_REQUEST;k(f,r,++o);o+=4;if(e){f.utf8Write(e,o,r);o+=r}k(f,s,o);o+=4;if(t){f.utf8Write(t,o,s);o+=s}k(f,0,o);k(f,n.length,o+=4);o+=4;for(let e=0;e<n.length;++e){const t=n[e];const i=Buffer.byteLength(t.prompt);k(f,i,o);o+=4;if(i){f.utf8Write(t.prompt,o,i);o+=i}f[o++]=t.echo?1:0}this._debug&&this._debug("Outbound: Sending USERAUTH_INFO_REQUEST");B(this,this._packetRW.write.finalize(f))}}const F=/^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;function parseHeader(e,t,n){let r;let s;if(this._buffer){r=Buffer.allocUnsafe(this._buffer.length+(n-t));r.set(this._buffer,0);if(t===0){r.set(e,this._buffer.length)}else{r.set(new Uint8Array(e.buffer,e.byteOffset+t,n-t),this._buffer.length)}s=this._buffer.length;t=0}else{r=e;s=0}const f=t;let h=t;let l=t;let u=false;let A=0;let g=0;for(;t<r.length;++t){const e=r[t];if(e===13){u=true;continue}if(e===10){if(l>h&&l-h>4&&r[h]===83&&r[h+1]===83&&r[h+2]===72&&r[h+3]===45){const e=r.latin1Slice(f,l+1);const u=h===f?e:e.slice(h-f);const A=F.exec(u);if(!A)throw new Error("Invalid identification string");const g={greeting:h===f?"":e.slice(0,h-f),identRaw:u,versions:{protocol:A[1],software:A[2]},comments:A[3]};this._remoteIdentRaw=Buffer.from(u);this._debug&&this._debug(`Remote ident: ${i(u)}`);this._compatFlags=getCompatFlags(g);this._buffer=undefined;this._decipher=new o(0,E.bind(this,{firstPacket:true}));this._parse=parsePacket;this._onHeader(g);if(!this._destruct){return n}p(this);return t+1-s}if(this._server)throw new Error("Greetings from clients not permitted");if(++g>D)throw new Error("Max greeting lines exceeded");u=false;h=t+1;A=0}else if(u){throw new Error("Invalid header: expected newline")}else if(++A>=O){throw new Error("Header line too long")}l=t}if(!this._buffer)this._buffer=w(r,f);return t-s}function parsePacket(e,t,n){return this._decipher.decrypt(e,t,n)}function onPayload(e){this._onPacket();if(e.length===0){this._debug&&this._debug("Inbound: Skipping empty packet payload");return}e=this._packetRW.read.read(e);const t=e[0];if(t===l.USERAUTH_SUCCESS&&!this._server&&!this._authenticated){this._authenticated=true;if(this._kex.negotiated.cs.compress==="zlib@openssh.com")this._packetRW.write=new P(this);if(this._kex.negotiated.sc.compress==="zlib@openssh.com")this._packetRW.read=new T}const n=S[t];if(n===undefined){this._debug&&this._debug(`Inbound: Unsupported message type: ${t}`);return}return n(this,e)}function getCompatFlags(e){const t=e.versions.software;let n=0;for(const e of f){if(typeof e[0]==="string"){if(t===e[0])n|=e[1]}else if(e[0].test(t)){n|=e[1]}}return n}function modesToBytes(e){const t=Object.keys(e);const n=Buffer.allocUnsafe(5*t.length+1);let i=0;for(let r=0;r<t.length;++r){const s=t[r];if(s==="TTY_OP_END")continue;const o=A[s];if(o===undefined)continue;const f=e[s];if(typeof f==="number"&&isFinite(f)){n[i++]=o;n[i++]=f>>>24;n[i++]=f>>>16;n[i++]=f>>>8;n[i++]=f}}n[i++]=A.TTY_OP_END;if(i<n.length)return w(n,0,i);return n}e.exports=Protocol},58:(e,t,n)=>{const i=n(361);const r=n(147);const{constants:s}=r;const{Readable:o,Writable:f}=n(781);const{inherits:h,types:l}=n(837);const u=l.isDate;const A=Buffer[Symbol.species];const{bufferCopy:g,bufferSlice:_,makeBufferParser:p,writeUInt32BE:E}=n(223);const b={SIZE:1,UIDGID:2,PERMISSIONS:4,ACMODTIME:8,EXTENDED:2147483648};const S=Buffer.alloc(28);const y={OK:0,EOF:1,NO_SUCH_FILE:2,PERMISSION_DENIED:3,FAILURE:4,BAD_MESSAGE:5,NO_CONNECTION:6,CONNECTION_LOST:7,OP_UNSUPPORTED:8};const m=new Map(Object.values(y).map((e=>[e,1])));const w={[y.OK]:"No error",[y.EOF]:"End of file",[y.NO_SUCH_FILE]:"No such file or directory",[y.PERMISSION_DENIED]:"Permission denied",[y.FAILURE]:"Failure",[y.BAD_MESSAGE]:"Bad message",[y.NO_CONNECTION]:"No connection",[y.CONNECTION_LOST]:"Connection lost",[y.OP_UNSUPPORTED]:"Operation unsupported"};const C={INIT:1,OPEN:3,CLOSE:4,READ:5,WRITE:6,LSTAT:7,FSTAT:8,SETSTAT:9,FSETSTAT:10,OPENDIR:11,READDIR:12,REMOVE:13,MKDIR:14,RMDIR:15,REALPATH:16,STAT:17,RENAME:18,READLINK:19,SYMLINK:20,EXTENDED:200};const B={VERSION:2,STATUS:101,HANDLE:102,DATA:103,NAME:104,ATTRS:105,EXTENDED:201};const k={READ:1,WRITE:2,APPEND:4,CREAT:8,TRUNC:16,EXCL:32};const R=2*1024;const N=2**32-1;const T=Buffer.from([0,0,0,5,C.INIT,0,0,0,3]);const P=Buffer.from([0,0,0,5,B.VERSION,0,0,0,3]);const U=/^SSH-2.0-(?:OpenSSH|dropbear)/;const Q=256*1024;const L=p();const O={readable:false,writable:false,push:e=>{},once:()=>{},on:()=>{},emit:()=>{},end:()=>{}};function noop(){}class SFTP extends i{constructor(e,t,n){super();if(typeof n!=="object"||!n)n={};const i=e._protocol._remoteIdentRaw;this.server=!!n.server;this._debug=typeof n.debug==="function"?n.debug:undefined;this._isOpenSSH=i&&U.test(i);this._version=-1;this._extensions={};this._biOpt=n.biOpt;this._pktLenBytes=0;this._pktLen=0;this._pktPos=0;this._pktType=0;this._pktData=undefined;this._writeReqid=-1;this._requests={};this._maxInPktLen=Q;this._maxOutPktLen=34e3;this._maxReadLen=(this._isOpenSSH?Q:34e3)-R;this._maxWriteLen=(this._isOpenSSH?Q:34e3)-R;this.maxOpenHandles=undefined;this._client=e;this._protocol=e._protocol;this._callbacks=[];this._hasX11=false;this._exit={code:undefined,signal:undefined,dump:undefined,desc:undefined};this._waitWindow=false;this._chunkcb=undefined;this._buffer=[];this.type=t.type;this.subtype=undefined;this.incoming=t.incoming;this.outgoing=t.outgoing;this.stderr=O;this.readable=true}push(e){if(e===null){cleanupRequests(this);if(!this.readable)return;this.readable=false;this.emit("end");return}let t=0;while(t<e.length){if(this._pktLenBytes<4){let n=Math.min(4-this._pktLenBytes,e.length-t);this._pktLenBytes+=n;while(n--)this._pktLen=(this._pktLen<<8)+e[t++];if(this._pktLenBytes<4)return;if(this._pktLen===0)return doFatalSFTPError(this,"Invalid packet length");if(this._pktLen>this._maxInPktLen){const e=this._maxInPktLen;return doFatalSFTPError(this,`Packet length ${this._pktLen} exceeds max length of ${e}`)}if(t>=e.length)return}if(this._pktPos<this._pktLen){const n=Math.min(this._pktLen-this._pktPos,e.length-t);if(t!==0||n!==e.length){if(n===this._pktLen){this._pkt=new A(e.buffer,e.byteOffset+t,n)}else{if(!this._pkt)this._pkt=Buffer.allocUnsafe(this._pktLen);this._pkt.set(new Uint8Array(e.buffer,e.byteOffset+t,n),this._pktPos)}}else if(n===this._pktLen){this._pkt=e}else{if(!this._pkt)this._pkt=Buffer.allocUnsafe(this._pktLen);this._pkt.set(e,this._pktPos)}t+=n;this._pktPos+=n;if(this._pktPos<this._pktLen)return}const n=this._pkt[0];const i=this._pkt;this._pktLen=0;this._pktLenBytes=0;this._pkt=undefined;this._pktPos=0;const r=this.server?F[n]:H[n];if(!r)return doFatalSFTPError(this,`Unknown packet type ${n}`);if(this._version===-1){if(this.server){if(n!==C.INIT)return doFatalSFTPError(this,`Expected INIT packet, got ${n}`)}else if(n!==B.VERSION){return doFatalSFTPError(this,`Expected VERSION packet, got ${n}`)}}if(r(this,i)===false)return}}end(){this.destroy()}destroy(){if(this.outgoing.state==="open"||this.outgoing.state==="eof"){this.outgoing.state="closing";this._protocol.channelClose(this.outgoing.id)}}_init(){this._init=noop;if(!this.server)sendOrBuffer(this,T)}createReadStream(e,t){if(this.server)throw new Error("Client-only method called in server mode");return new ReadStream(this,e,t)}createWriteStream(e,t){if(this.server)throw new Error("Client-only method called in server mode");return new WriteStream(this,e,t)}open(e,t,n,i){if(this.server)throw new Error("Client-only method called in server mode");if(typeof n==="function"){i=n;n=undefined}const r=typeof t==="number"?t:stringToFlags(t);if(r===null)throw new Error(`Unknown flags string: ${t}`);let s=0;let o=0;if(typeof n==="string"||typeof n==="number")n={mode:n};if(typeof n==="object"&&n!==null){n=attrsToBytes(n);s=n.flags;o=n.nb}const f=Buffer.byteLength(e);let h=9;const l=Buffer.allocUnsafe(4+1+4+4+f+4+4+o);E(l,l.length-4,0);l[4]=C.OPEN;const u=this._writeReqid=this._writeReqid+1&N;E(l,u,5);E(l,f,h);l.utf8Write(e,h+=4,f);E(l,r,h+=f);E(l,s,h+=4);if(o){h+=4;if(o===S.length)l.set(S,h);else g(S,l,0,o,h);h+=o}this._requests[u]={cb:i};const A=sendOrBuffer(this,l);this._debug&&this._debug(`SFTP: Outbound: ${A?"Buffered":"Sending"} OPEN`)}close(e,t){if(this.server)throw new Error("Client-only method called in server mode");if(!Buffer.isBuffer(e))throw new Error("handle is not a Buffer");const n=e.length;let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.CLOSE;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.set(e,i+=4);this._requests[s]={cb:t};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} CLOSE`)}read(e,t,n,i,r,s){if(this.server)throw new Error("Client-only method called in server mode");if(!Buffer.isBuffer(e))throw new Error("handle is not a Buffer");if(!Buffer.isBuffer(t))throw new Error("buffer is not a Buffer");if(n>=t.length)throw new Error("offset is out of bounds");if(n+i>t.length)throw new Error("length extends beyond buffer");if(r===null)throw new Error("null position currently unsupported");read_(this,e,t,n,i,r,s)}readData(e,t,n,i,r,s){this.read(e,t,n,i,r,s)}write(e,t,n,i,r,s){if(this.server)throw new Error("Client-only method called in server mode");if(!Buffer.isBuffer(e))throw new Error("handle is not a Buffer");if(!Buffer.isBuffer(t))throw new Error("buffer is not a Buffer");if(n>t.length)throw new Error("offset is out of bounds");if(n+i>t.length)throw new Error("length extends beyond buffer");if(r===null)throw new Error("null position currently unsupported");if(!i){s&&process.nextTick(s,undefined,0);return}const o=this._maxWriteLen;const f=Math.max(i-o,0);const h=r;if(f)i=o;const l=e.length;let u=9;const A=Buffer.allocUnsafe(4+1+4+4+l+8+4+i);E(A,A.length-4,0);A[4]=C.WRITE;const _=this._writeReqid=this._writeReqid+1&N;E(A,_,5);E(A,l,u);A.set(e,u+=4);u+=l;for(let e=7;e>=0;--e){A[u+e]=r&255;r/=256}E(A,i,u+=8);g(t,A,n,n+i,u+=4);this._requests[_]={cb:r=>{if(r){if(typeof s==="function")s(r)}else if(f){this.write(e,t,n+i,f,h+i,s)}else if(typeof s==="function"){s(undefined,n+i)}}};const p=sendOrBuffer(this,A);if(this._debug){const e=p?"Sent":"Buffered";this._debug(`SFTP: Outbound: ${e} WRITE (id:${_})`)}}writeData(e,t,n,i,r,s){this.write(e,t,n,i,r,s)}fastGet(e,t,n,i){if(this.server)throw new Error("Client-only method called in server mode");fastXfer(this,r,e,t,n,i)}fastPut(e,t,n,i){if(this.server)throw new Error("Client-only method called in server mode");fastXfer(r,this,e,t,n,i)}readFile(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");let i;if(typeof n==="function"){i=n}else if(typeof t==="function"){i=t;t=undefined}if(typeof t==="string")t={encoding:t,flag:"r"};else if(!t)t={encoding:null,flag:"r"};else if(typeof t!=="object")throw new TypeError("Bad arguments");const r=t.encoding;if(r&&!Buffer.isEncoding(r))throw new Error(`Unknown encoding: ${r}`);let s;let o;let f;let h=0;let l;let u=0;const A=t.flag||"r";const read=()=>{if(s===0){o=Buffer.allocUnsafe(8192);this.read(l,o,0,8192,u,afterRead)}else{this.read(l,o,h,s-h,u,afterRead)}};const afterRead=(e,t)=>{let n;if(e){n=e.code===y.EOF;if(!n){return this.close(l,(()=>i&&i(e)))}}else{n=false}if(n||s===0&&t===0)return close();u+=t;h+=t;if(s!==0){if(h===s)close();else read()}else{f.push(_(o,0,t));read()}};afterRead._wantEOFError=true;const close=()=>{this.close(l,(e=>{if(s===0){o=Buffer.concat(f,h)}else if(h<s){o=_(o,0,h)}if(r)o=o.toString(r);return i&&i(e,o)}))};this.open(e,A,438,((t,n)=>{if(t)return i&&i(t);l=n;const tryStat=(t,n)=>{if(t){this.stat(e,((e,n)=>{if(e){return this.close(l,(()=>{i&&i(t)}))}tryStat(null,n)}));return}s=n.size||0;if(s===0){f=[];return read()}o=Buffer.allocUnsafe(s);read()};this.fstat(l,tryStat)}))}writeFile(e,t,n,i){if(this.server)throw new Error("Client-only method called in server mode");let r;if(typeof i==="function"){r=i}else if(typeof n==="function"){r=n;n=undefined}if(typeof n==="string")n={encoding:n,mode:438,flag:"w"};else if(!n)n={encoding:"utf8",mode:438,flag:"w"};else if(typeof n!=="object")throw new TypeError("Bad arguments");if(n.encoding&&!Buffer.isEncoding(n.encoding))throw new Error(`Unknown encoding: ${n.encoding}`);const s=n.flag||"w";this.open(e,s,n.mode,((i,o)=>{if(i){r&&r(i)}else{const i=Buffer.isBuffer(t)?t:Buffer.from(""+t,n.encoding||"utf8");const f=/a/.test(s)?null:0;if(f===null){const tryStat=(t,n)=>{if(t){this.stat(e,((e,n)=>{if(e){return this.close(o,(()=>{r&&r(t)}))}tryStat(null,n)}));return}writeAll(this,o,i,0,i.length,n.size,r)};this.fstat(o,tryStat);return}writeAll(this,o,i,0,i.length,f,r)}}))}appendFile(e,t,n,i){if(this.server)throw new Error("Client-only method called in server mode");let r;if(typeof i==="function"){r=i}else if(typeof n==="function"){r=n;n=undefined}if(typeof n==="string")n={encoding:n,mode:438,flag:"a"};else if(!n)n={encoding:"utf8",mode:438,flag:"a"};else if(typeof n!=="object")throw new TypeError("Bad arguments");if(!n.flag)n=Object.assign({flag:"a"},n);this.writeFile(e,t,n,r)}exists(e,t){if(this.server)throw new Error("Client-only method called in server mode");this.stat(e,(e=>{t&&t(e?false:true)}))}unlink(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.REMOVE;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.utf8Write(e,i+=4,n);this._requests[s]={cb:t};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} REMOVE`)}rename(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");const i=Buffer.byteLength(e);const r=Buffer.byteLength(t);let s=9;const o=Buffer.allocUnsafe(4+1+4+4+i+4+r);E(o,o.length-4,0);o[4]=C.RENAME;const f=this._writeReqid=this._writeReqid+1&N;E(o,f,5);E(o,i,s);o.utf8Write(e,s+=4,i);E(o,r,s+=i);o.utf8Write(t,s+=4,r);this._requests[f]={cb:n};const h=sendOrBuffer(this,o);this._debug&&this._debug(`SFTP: Outbound: ${h?"Buffered":"Sending"} RENAME`)}mkdir(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");let i=0;let r=0;if(typeof t==="function"){n=t;t=undefined}if(typeof t==="object"&&t!==null){t=attrsToBytes(t);i=t.flags;r=t.nb}const s=Buffer.byteLength(e);let o=9;const f=Buffer.allocUnsafe(4+1+4+4+s+4+r);E(f,f.length-4,0);f[4]=C.MKDIR;const h=this._writeReqid=this._writeReqid+1&N;E(f,h,5);E(f,s,o);f.utf8Write(e,o+=4,s);E(f,i,o+=s);if(r){o+=4;if(r===S.length)f.set(S,o);else g(S,f,0,r,o);o+=r}this._requests[h]={cb:n};const l=sendOrBuffer(this,f);this._debug&&this._debug(`SFTP: Outbound: ${l?"Buffered":"Sending"} MKDIR`)}rmdir(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.RMDIR;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.utf8Write(e,i+=4,n);this._requests[s]={cb:t};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} RMDIR`)}readdir(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");if(typeof t==="function"){n=t;t={}}if(typeof t!=="object"||t===null)t={};const i=t&&t.full?false:true;if(!Buffer.isBuffer(e)&&typeof e!=="string")throw new Error("missing directory handle or path");if(typeof e==="string"){const i=[];let r=0;const reread=(e,s)=>{if(e)return n(e);this.readdir(s,t,((e,t)=>{const o=e&&e.code===y.EOF;if(e&&!o)return this.close(s,(()=>n(e)));if(o){return this.close(s,(e=>{if(e)return n(e);n(undefined,i)}))}for(let e=0;e<t.length;++e,++r)i[r]=t[e];reread(undefined,s)}))};return this.opendir(e,reread)}const r=e.length;let s=9;const o=Buffer.allocUnsafe(4+1+4+4+r);E(o,o.length-4,0);o[4]=C.READDIR;const f=this._writeReqid=this._writeReqid+1&N;E(o,f,5);E(o,r,s);o.set(e,s+=4);this._requests[f]={cb:i?(e,t)=>{if(typeof n!=="function")return;if(e)return n(e);for(let e=t.length-1;e>=0;--e){if(t[e].filename==="."||t[e].filename==="..")t.splice(e,1)}n(undefined,t)}:n};const h=sendOrBuffer(this,o);this._debug&&this._debug(`SFTP: Outbound: ${h?"Buffered":"Sending"} READDIR`)}fstat(e,t){if(this.server)throw new Error("Client-only method called in server mode");if(!Buffer.isBuffer(e))throw new Error("handle is not a Buffer");const n=e.length;let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.FSTAT;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.set(e,i+=4);this._requests[s]={cb:t};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} FSTAT`)}stat(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.STAT;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.utf8Write(e,i+=4,n);this._requests[s]={cb:t};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} STAT`)}lstat(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.LSTAT;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.utf8Write(e,i+=4,n);this._requests[s]={cb:t};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} LSTAT`)}opendir(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.OPENDIR;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.utf8Write(e,i+=4,n);this._requests[s]={cb:t};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} OPENDIR`)}setstat(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");let i=0;let r=0;if(typeof t==="object"&&t!==null){t=attrsToBytes(t);i=t.flags;r=t.nb}else if(typeof t==="function"){n=t}const s=Buffer.byteLength(e);let o=9;const f=Buffer.allocUnsafe(4+1+4+4+s+4+r);E(f,f.length-4,0);f[4]=C.SETSTAT;const h=this._writeReqid=this._writeReqid+1&N;E(f,h,5);E(f,s,o);f.utf8Write(e,o+=4,s);E(f,i,o+=s);if(r){o+=4;if(r===S.length)f.set(S,o);else g(S,f,0,r,o);o+=r}this._requests[h]={cb:n};const l=sendOrBuffer(this,f);this._debug&&this._debug(`SFTP: Outbound: ${l?"Buffered":"Sending"} SETSTAT`)}fsetstat(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");if(!Buffer.isBuffer(e))throw new Error("handle is not a Buffer");let i=0;let r=0;if(typeof t==="object"&&t!==null){t=attrsToBytes(t);i=t.flags;r=t.nb}else if(typeof t==="function"){n=t}const s=e.length;let o=9;const f=Buffer.allocUnsafe(4+1+4+4+s+4+r);E(f,f.length-4,0);f[4]=C.FSETSTAT;const h=this._writeReqid=this._writeReqid+1&N;E(f,h,5);E(f,s,o);f.set(e,o+=4);E(f,i,o+=s);if(r){o+=4;if(r===S.length)f.set(S,o);else g(S,f,0,r,o);o+=r}this._requests[h]={cb:n};const l=sendOrBuffer(this,f);this._debug&&this._debug(`SFTP: Outbound: ${l?"Buffered":"Sending"} FSETSTAT`)}futimes(e,t,n,i){return this.fsetstat(e,{atime:toUnixTimestamp(t),mtime:toUnixTimestamp(n)},i)}utimes(e,t,n,i){return this.setstat(e,{atime:toUnixTimestamp(t),mtime:toUnixTimestamp(n)},i)}fchown(e,t,n,i){return this.fsetstat(e,{uid:t,gid:n},i)}chown(e,t,n,i){return this.setstat(e,{uid:t,gid:n},i)}fchmod(e,t,n){return this.fsetstat(e,{mode:t},n)}chmod(e,t,n){return this.setstat(e,{mode:t},n)}readlink(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.READLINK;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.utf8Write(e,i+=4,n);this._requests[s]={cb:(e,n)=>{if(typeof t!=="function")return;if(e)return t(e);if(!n||!n.length)return t(new Error("Response missing link info"));t(undefined,n[0].filename)}};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} READLINK`)}symlink(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");const i=Buffer.byteLength(t);const r=Buffer.byteLength(e);let s=9;const o=Buffer.allocUnsafe(4+1+4+4+i+4+r);E(o,o.length-4,0);o[4]=C.SYMLINK;const f=this._writeReqid=this._writeReqid+1&N;E(o,f,5);if(this._isOpenSSH){E(o,r,s);o.utf8Write(e,s+=4,r);E(o,i,s+=r);o.utf8Write(t,s+=4,i)}else{E(o,i,s);o.utf8Write(t,s+=4,i);E(o,r,s+=i);o.utf8Write(e,s+=4,r)}this._requests[f]={cb:n};const h=sendOrBuffer(this,o);this._debug&&this._debug(`SFTP: Outbound: ${h?"Buffered":"Sending"} SYMLINK`)}realpath(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=Buffer.byteLength(e);let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=C.REALPATH;const s=this._writeReqid=this._writeReqid+1&N;E(r,s,5);E(r,n,i);r.utf8Write(e,i+=4,n);this._requests[s]={cb:(e,n)=>{if(typeof t!=="function")return;if(e)return t(e);if(!n||!n.length)return t(new Error("Response missing path info"));t(undefined,n[0].filename)}};const o=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} REALPATH`)}ext_openssh_rename(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");const i=this._extensions["posix-rename@openssh.com"];if(!i||i!=="1")throw new Error("Server does not support this extended request");const r=Buffer.byteLength(e);const s=Buffer.byteLength(t);let o=9;const f=Buffer.allocUnsafe(4+1+4+4+24+4+r+4+s);E(f,f.length-4,0);f[4]=C.EXTENDED;const h=this._writeReqid=this._writeReqid+1&N;E(f,h,5);E(f,24,o);f.utf8Write("posix-rename@openssh.com",o+=4,24);E(f,r,o+=24);f.utf8Write(e,o+=4,r);E(f,s,o+=r);f.utf8Write(t,o+=4,s);this._requests[h]={cb:n};const l=sendOrBuffer(this,f);if(this._debug){const e=l?"Buffered":"Sending";this._debug(`SFTP: Outbound: ${e} posix-rename@openssh.com`)}}ext_openssh_statvfs(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=this._extensions["statvfs@openssh.com"];if(!n||n!=="2")throw new Error("Server does not support this extended request");const i=Buffer.byteLength(e);let r=9;const s=Buffer.allocUnsafe(4+1+4+4+19+4+i);E(s,s.length-4,0);s[4]=C.EXTENDED;const o=this._writeReqid=this._writeReqid+1&N;E(s,o,5);E(s,19,r);s.utf8Write("statvfs@openssh.com",r+=4,19);E(s,i,r+=19);s.utf8Write(e,r+=4,i);this._requests[o]={extended:"statvfs@openssh.com",cb:t};const f=sendOrBuffer(this,s);if(this._debug){const e=f?"Buffered":"Sending";this._debug(`SFTP: Outbound: ${e} statvfs@openssh.com`)}}ext_openssh_fstatvfs(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=this._extensions["fstatvfs@openssh.com"];if(!n||n!=="2")throw new Error("Server does not support this extended request");if(!Buffer.isBuffer(e))throw new Error("handle is not a Buffer");const i=e.length;let r=9;const s=Buffer.allocUnsafe(4+1+4+4+20+4+i);E(s,s.length-4,0);s[4]=C.EXTENDED;const o=this._writeReqid=this._writeReqid+1&N;E(s,o,5);E(s,20,r);s.utf8Write("fstatvfs@openssh.com",r+=4,20);E(s,i,r+=20);s.set(e,r+=4);this._requests[o]={extended:"fstatvfs@openssh.com",cb:t};const f=sendOrBuffer(this,s);if(this._debug){const e=f?"Buffered":"Sending";this._debug(`SFTP: Outbound: ${e} fstatvfs@openssh.com`)}}ext_openssh_hardlink(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");const i=this._extensions["hardlink@openssh.com"];if(i!=="1")throw new Error("Server does not support this extended request");const r=Buffer.byteLength(e);const s=Buffer.byteLength(t);let o=9;const f=Buffer.allocUnsafe(4+1+4+4+20+4+r+4+s);E(f,f.length-4,0);f[4]=C.EXTENDED;const h=this._writeReqid=this._writeReqid+1&N;E(f,h,5);E(f,20,o);f.utf8Write("hardlink@openssh.com",o+=4,20);E(f,r,o+=20);f.utf8Write(e,o+=4,r);E(f,s,o+=r);f.utf8Write(t,o+=4,s);this._requests[h]={cb:n};const l=sendOrBuffer(this,f);if(this._debug){const e=l?"Buffered":"Sending";this._debug(`SFTP: Outbound: ${e} hardlink@openssh.com`)}}ext_openssh_fsync(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=this._extensions["fsync@openssh.com"];if(n!=="1")throw new Error("Server does not support this extended request");if(!Buffer.isBuffer(e))throw new Error("handle is not a Buffer");const i=e.length;let r=9;const s=Buffer.allocUnsafe(4+1+4+4+17+4+i);E(s,s.length-4,0);s[4]=C.EXTENDED;const o=this._writeReqid=this._writeReqid+1&N;E(s,o,5);E(s,17,r);s.utf8Write("fsync@openssh.com",r+=4,17);E(s,i,r+=17);s.set(e,r+=4);this._requests[o]={cb:t};const f=sendOrBuffer(this,s);this._debug&&this._debug(`SFTP: Outbound: ${f?"Buffered":"Sending"} fsync@openssh.com`)}ext_openssh_lsetstat(e,t,n){if(this.server)throw new Error("Client-only method called in server mode");const i=this._extensions["lsetstat@openssh.com"];if(i!=="1")throw new Error("Server does not support this extended request");let r=0;let s=0;if(typeof t==="object"&&t!==null){t=attrsToBytes(t);r=t.flags;s=t.nb}else if(typeof t==="function"){n=t}const o=Buffer.byteLength(e);let f=9;const h=Buffer.allocUnsafe(4+1+4+4+20+4+o+4+s);E(h,h.length-4,0);h[4]=C.EXTENDED;const l=this._writeReqid=this._writeReqid+1&N;E(h,l,5);E(h,20,f);h.utf8Write("lsetstat@openssh.com",f+=4,20);E(h,o,f+=20);h.utf8Write(e,f+=4,o);E(h,r,f+=o);if(s){f+=4;if(s===S.length)h.set(S,f);else g(S,h,0,s,f);f+=s}this._requests[l]={cb:n};const u=sendOrBuffer(this,h);if(this._debug){const e=u?"Buffered":"Sending";this._debug(`SFTP: Outbound: ${e} lsetstat@openssh.com`)}}ext_openssh_expandPath(e,t){if(this.server)throw new Error("Client-only method called in server mode");const n=this._extensions["expand-path@openssh.com"];if(n!=="1")throw new Error("Server does not support this extended request");const i=Buffer.byteLength(e);let r=9;const s=Buffer.allocUnsafe(4+1+4+4+23+4+i);E(s,s.length-4,0);s[4]=C.EXTENDED;const o=this._writeReqid=this._writeReqid+1&N;E(s,o,5);E(s,23,r);s.utf8Write("expand-path@openssh.com",r+=4,23);E(s,i,r+=20);s.utf8Write(e,r+=4,i);this._requests[o]={cb:t};const f=sendOrBuffer(this,s);if(this._debug){const e=f?"Buffered":"Sending";this._debug(`SFTP: Outbound: ${e} expand-path@openssh.com`)}}handle(e,t){if(!this.server)throw new Error("Server-only method called in client mode");if(!Buffer.isBuffer(t))throw new Error("handle is not a Buffer");const n=t.length;if(n>256)throw new Error("handle too large (> 256 bytes)");let i=9;const r=Buffer.allocUnsafe(4+1+4+4+n);E(r,r.length-4,0);r[4]=B.HANDLE;E(r,e,5);E(r,n,i);if(n)r.set(t,i+=4);const s=sendOrBuffer(this,r);this._debug&&this._debug(`SFTP: Outbound: ${s?"Buffered":"Sending"} HANDLE`)}status(e,t,n){if(!this.server)throw new Error("Server-only method called in client mode");if(!m.has(t))throw new Error(`Bad status code: ${t}`);n||(n="");const i=Buffer.byteLength(n);let r=9;const s=Buffer.allocUnsafe(4+1+4+4+4+i+4);E(s,s.length-4,0);s[4]=B.STATUS;E(s,e,5);E(s,t,r);E(s,i,r+=4);r+=4;if(i){s.utf8Write(n,r,i);r+=i}E(s,0,r);const o=sendOrBuffer(this,s);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} STATUS`)}data(e,t,n){if(!this.server)throw new Error("Server-only method called in client mode");const i=Buffer.isBuffer(t);if(!i&&typeof t!=="string")throw new Error("data is not a Buffer or string");let r;if(!i&&!n){n=undefined;r=true}const s=i?t.length:Buffer.byteLength(t,n);let o=9;const f=Buffer.allocUnsafe(4+1+4+4+s);E(f,f.length-4,0);f[4]=B.DATA;E(f,e,5);E(f,s,o);if(s){if(i)f.set(t,o+=4);else if(r)f.utf8Write(t,o+=4,s);else f.write(t,o+=4,s,n)}const h=sendOrBuffer(this,f);this._debug&&this._debug(`SFTP: Outbound: ${h?"Buffered":"Sending"} DATA`)}name(e,t){if(!this.server)throw new Error("Server-only method called in client mode");if(!Array.isArray(t)){if(typeof t!=="object"||t===null)throw new Error("names is not an object or array");t=[t]}const n=t.length;let i=0;let r;const s=[];for(let e=0;e<n;++e){const n=t[e];const o=!n||!n.filename||typeof n.filename!=="string"?"":n.filename;i+=4+Buffer.byteLength(o);const f=!n||!n.longname||typeof n.longname!=="string"?"":n.longname;i+=4+Buffer.byteLength(f);if(typeof n.attrs==="object"&&n.attrs!==null){r=attrsToBytes(n.attrs);i+=4+r.nb;if(r.nb){let e;if(r.nb===S.length){e=new Uint8Array(S)}else{e=new Uint8Array(r.nb);g(S,e,0,r.nb,0)}r.bytes=e}s.push(r)}else{i+=4;s.push(null)}}let o=9;const f=Buffer.allocUnsafe(4+1+4+4+i);E(f,f.length-4,0);f[4]=B.NAME;E(f,e,5);E(f,n,o);o+=4;for(let e=0;e<n;++e){const n=t[e];{const e=!n||!n.filename||typeof n.filename!=="string"?"":n.filename;const t=Buffer.byteLength(e);E(f,t,o);o+=4;if(t){f.utf8Write(e,o,t);o+=t}}{const e=!n||!n.longname||typeof n.longname!=="string"?"":n.longname;const t=Buffer.byteLength(e);E(f,t,o);o+=4;if(t){f.utf8Write(e,o,t);o+=t}}const i=s[e];if(i){E(f,i.flags,o);o+=4;if(i.flags&&i.bytes){f.set(i.bytes,o);o+=i.nb}}else{E(f,0,o);o+=4}}const h=sendOrBuffer(this,f);this._debug&&this._debug(`SFTP: Outbound: ${h?"Buffered":"Sending"} NAME`)}attrs(e,t){if(!this.server)throw new Error("Server-only method called in client mode");if(typeof t!=="object"||t===null)throw new Error("attrs is not an object");t=attrsToBytes(t);const n=t.flags;const i=t.nb;let r=9;const s=Buffer.allocUnsafe(4+1+4+4+i);E(s,s.length-4,0);s[4]=B.ATTRS;E(s,e,5);E(s,n,r);if(i){r+=4;if(i===S.length)s.set(S,r);else g(S,s,0,i,r);r+=i}const o=sendOrBuffer(this,s);this._debug&&this._debug(`SFTP: Outbound: ${o?"Buffered":"Sending"} ATTRS`)}}function tryCreateBuffer(e){try{return Buffer.allocUnsafe(e)}catch(e){return e}}function read_(e,t,n,i,r,s,o,f){const h=e._maxReadLen;const l=Math.max(r-h,0);if(l)r=h;const u=t.length;let A=9;let g=s;const p=Buffer.allocUnsafe(4+1+4+4+u+8+4);E(p,p.length-4,0);p[4]=C.READ;const b=e._writeReqid=e._writeReqid+1&N;E(p,b,5);E(p,u,A);p.set(t,A+=4);A+=u;for(let e=7;e>=0;--e){p[A+e]=g&255;g/=256}E(p,r,A+=8);if(typeof o!=="function")o=noop;const S=f||{nb:0,position:s,off:i,origOff:i,len:undefined,overflow:undefined,cb:(i,r,s)=>{const f=S.len;const h=S.overflow;if(i){if(o._wantEOFError||i.code!==y.EOF)return o(i)}else if(s>f){return o(new Error("Received more data than requested"))}else if(s===f&&h){S.nb+=s;S.position+=s;S.off+=s;read_(e,t,n,S.off,h,S.position,o,S);return}if(S.origOff===0&&n.length===S.nb)r=n;else r=_(n,S.origOff,S.origOff+S.nb);o(undefined,S.nb+(s||0),r,S.position)},buffer:undefined};S.len=r;S.overflow=l;S.buffer=_(n,i,i+r);e._requests[b]=S;const m=sendOrBuffer(e,p);e._debug&&e._debug(`SFTP: Outbound: ${m?"Buffered":"Sending"} READ`)}function fastXfer(e,t,n,i,s,o){let f=64;let h=32768;let l;let u;let A;if(typeof s==="function"){o=s}else if(typeof s==="object"&&s!==null){if(typeof s.concurrency==="number"&&s.concurrency>0&&!isNaN(s.concurrency)){f=s.concurrency}if(typeof s.chunkSize==="number"&&s.chunkSize>0&&!isNaN(s.chunkSize)){h=s.chunkSize}if(typeof s.fileSize==="number"&&s.fileSize>0&&!isNaN(s.fileSize)){A=s.fileSize}if(typeof s.step==="function")l=s.step;if(typeof s.mode==="string"||typeof s.mode==="number")u=modeNum(s.mode)}let g;let _=0;let p=0;let E=false;let b;let S;let y;let m=h*f;function onerror(n){if(E)return;E=true;let i=0;let s;if(b||S){s=()=>{if(--i===0)o(n)};if(b&&(e===r||e.outgoing.state==="open"))++i;if(S&&(t===r||t.outgoing.state==="open"))++i;if(b&&(e===r||e.outgoing.state==="open"))e.close(b,s);if(S&&(t===r||t.outgoing.state==="open"))t.close(S,s)}else{o(n)}}e.open(n,"r",((s,E)=>{if(s)return onerror(s);b=E;if(A===undefined)e.fstat(b,tryStat);else tryStat(null,{size:A});function tryStat(s,A){if(s){if(e!==r){e.stat(n,((e,t)=>{if(e)return onerror(s);tryStat(null,t)}));return}return onerror(s)}g=A.size;t.open(i,"w",((n,r)=>{if(n)return onerror(n);S=r;if(g<=0)return onerror();while(m>g){if(f===1){m=g;break}m-=h;--f}y=tryCreateBuffer(m);if(y instanceof Error)return onerror(y);if(u!==undefined){t.fchmod(S,u,(function tryAgain(e){if(e){t.chmod(i,u,(e=>tryAgain()));return}startReads()}))}else{startReads()}function onread(n,i,r,s,f,u){if(n)return onerror(n);f=f||0;t.write(S,y,f,i,s,writeCb);function writeCb(n){if(n)return onerror(n);p+=i;l&&l(p,i,g);if(i<u)return singleRead(f,s+i,u-i);if(p===g){t.close(S,(t=>{S=undefined;if(t)return onerror(t);e.close(b,(e=>{b=undefined;if(e)return onerror(e);o()}))}));return}if(_>=g)return;const r=_+h>g?g-_:h;singleRead(f,_,r);_+=r}}function makeCb(e,t,n){return(i,r,s)=>{onread(i,r,s,t,e,n)}}function singleRead(t,n,i){e.read(b,y,t,i,n,makeCb(t,n,i))}function startReads(){let e=0;let t=0;while(_<g&&e<f){const n=_+h>g?g-_:h;singleRead(t,_,n);t+=n;_+=n;++e}}}))}}))}function writeAll(e,t,n,i,r,s,o){const f=typeof o==="function"?o:undefined;e.write(t,n,i,r,s,((o,h)=>{if(o){return e.close(t,(()=>{f&&f(o)}))}if(h===r){e.close(t,f)}else{i+=h;r-=h;s+=h;writeAll(e,t,n,i,r,s,f)}}))}class Stats{constructor(e){this.mode=e&&e.mode;this.uid=e&&e.uid;this.gid=e&&e.gid;this.size=e&&e.size;this.atime=e&&e.atime;this.mtime=e&&e.mtime;this.extended=e&&e.extended}isDirectory(){return(this.mode&s.S_IFMT)===s.S_IFDIR}isFile(){return(this.mode&s.S_IFMT)===s.S_IFREG}isBlockDevice(){return(this.mode&s.S_IFMT)===s.S_IFBLK}isCharacterDevice(){return(this.mode&s.S_IFMT)===s.S_IFCHR}isSymbolicLink(){return(this.mode&s.S_IFMT)===s.S_IFLNK}isFIFO(){return(this.mode&s.S_IFMT)===s.S_IFIFO}isSocket(){return(this.mode&s.S_IFMT)===s.S_IFSOCK}}function attrsToBytes(e){let t=0;let n=0;if(typeof e==="object"&&e!==null){if(typeof e.size==="number"){t|=b.SIZE;const i=e.size;S[n++]=i/72057594037927940;S[n++]=i/281474976710656;S[n++]=i/1099511627776;S[n++]=i/4294967296;S[n++]=i/16777216;S[n++]=i/65536;S[n++]=i/256;S[n++]=i}if(typeof e.uid==="number"&&typeof e.gid==="number"){t|=b.UIDGID;const i=e.uid;const r=e.gid;S[n++]=i>>>24;S[n++]=i>>>16;S[n++]=i>>>8;S[n++]=i;S[n++]=r>>>24;S[n++]=r>>>16;S[n++]=r>>>8;S[n++]=r}if(typeof e.mode==="number"||typeof e.mode==="string"){const i=modeNum(e.mode);t|=b.PERMISSIONS;S[n++]=i>>>24;S[n++]=i>>>16;S[n++]=i>>>8;S[n++]=i}if((typeof e.atime==="number"||u(e.atime))&&(typeof e.mtime==="number"||u(e.mtime))){const i=toUnixTimestamp(e.atime);const r=toUnixTimestamp(e.mtime);t|=b.ACMODTIME;S[n++]=i>>>24;S[n++]=i>>>16;S[n++]=i>>>8;S[n++]=i;S[n++]=r>>>24;S[n++]=r>>>16;S[n++]=r>>>8;S[n++]=r}}return{flags:t,nb:n}}function toUnixTimestamp(e){if(typeof e==="number"&&e===e)return e;if(u(e))return parseInt(e.getTime()/1e3,10);throw new Error(`Cannot parse time: ${e}`)}function modeNum(e){if(typeof e==="number"&&e===e)return e;if(typeof e==="string")return modeNum(parseInt(e,8));throw new Error(`Cannot parse mode: ${e}`)}const D={r:k.READ,"r+":k.READ|k.WRITE,w:k.TRUNC|k.CREAT|k.WRITE,wx:k.TRUNC|k.CREAT|k.WRITE|k.EXCL,xw:k.TRUNC|k.CREAT|k.WRITE|k.EXCL,"w+":k.TRUNC|k.CREAT|k.READ|k.WRITE,"wx+":k.TRUNC|k.CREAT|k.READ|k.WRITE|k.EXCL,"xw+":k.TRUNC|k.CREAT|k.READ|k.WRITE|k.EXCL,a:k.APPEND|k.CREAT|k.WRITE,ax:k.APPEND|k.CREAT|k.WRITE|k.EXCL,xa:k.APPEND|k.CREAT|k.WRITE|k.EXCL,"a+":k.APPEND|k.CREAT|k.READ|k.WRITE,"ax+":k.APPEND|k.CREAT|k.READ|k.WRITE|k.EXCL,"xa+":k.APPEND|k.CREAT|k.READ|k.WRITE|k.EXCL};function stringToFlags(e){const t=D[e];return t!==undefined?t:null}const v=(()=>{const e=Object.keys(D);return t=>{for(let n=0;n<e.length;++n){const i=e[n];if(D[i]===t)return i}return null}})();function readAttrs(e){const t=L.readUInt32BE();if(t===undefined)return;const n=new Stats;if(t&b.SIZE){const t=L.readUInt64BE(e);if(t===undefined)return;n.size=t}if(t&b.UIDGID){const e=L.readUInt32BE();const t=L.readUInt32BE();if(t===undefined)return;n.uid=e;n.gid=t}if(t&b.PERMISSIONS){const e=L.readUInt32BE();if(e===undefined)return;n.mode=e}if(t&b.ACMODTIME){const e=L.readUInt32BE();const t=L.readUInt32BE();if(t===undefined)return;n.atime=e;n.mtime=t}if(t&b.EXTENDED){const e=L.readUInt32BE();if(e===undefined)return;const t={};for(let n=0;n<e;++n){const e=L.readString(true);const n=L.readString();if(n===undefined)return;t[e]=n}n.extended=t}return n}function sendOrBuffer(e,t){const n=tryWritePayload(e,t);if(n!==undefined){e._buffer.push(n);return false}return true}function tryWritePayload(e,t){const n=e.outgoing;if(n.state!=="open")return;if(n.window===0){e._waitWindow=true;return t}let i;const r=t.length;let s=0;while(r-s>0&&n.window>0){const i=Math.min(r-s,n.window,n.packetSize);n.window-=i;if(n.window===0){e._waitWindow=true;e._chunkcb=drainBuffer}if(s===0&&i===r){e._protocol.channelData(e.outgoing.id,t)}else{e._protocol.channelData(e.outgoing.id,_(t,s,s+i))}s+=i}if(r-s>0){if(s>0)i=_(t,s,r);else i=t}return i}function drainBuffer(){this._chunkcb=undefined;const e=this._buffer;let t=0;while(t<e.length){const n=e[t];const i=tryWritePayload(this,n);if(i!==undefined){if(i!==n)e[t]=i;if(t>0)this._buffer=e.slice(t);return}++t}if(t>0)this._buffer=[]}function doFatalSFTPError(e,t,n){const i=new Error(t);i.level="sftp-protocol";if(!n&&e._debug)e._debug(`SFTP: Inbound: ${t}`);e.emit("error",i);e.destroy();cleanupRequests(e);return false}function cleanupRequests(e){const t=Object.keys(e._requests);if(t.length===0)return;const n=e._requests;e._requests={};const i=new Error("No response from server");for(let e=0;e<t.length;++e){const r=n[t[e]];if(typeof r.cb==="function")r.cb(i)}}function requestLimits(e,t){let n=9;const i=Buffer.allocUnsafe(4+1+4+4+18);E(i,i.length-4,0);i[4]=C.EXTENDED;const r=e._writeReqid=e._writeReqid+1&N;E(i,r,5);E(i,18,n);i.utf8Write("limits@openssh.com",n+=4,18);e._requests[r]={extended:"limits@openssh.com",cb:t};const s=sendOrBuffer(e,i);if(e._debug){const t=s?"Buffered":"Sending";e._debug(`SFTP: Outbound: ${t} limits@openssh.com`)}}const H={[B.VERSION]:(e,t)=>{if(e._version!==-1)return doFatalSFTPError(e,"Duplicate VERSION packet");const n={};L.init(t,1);let i=L.readUInt32BE();while(L.avail()){const e=L.readString(true);const t=L.readString(true);if(t===undefined){i=undefined;break}n[e]=t}L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed VERSION packet");if(e._debug){const t=Object.keys(n);if(t.length){e._debug(`SFTP: Inbound: Received VERSION (v${i}, exts:${t})`)}else{e._debug(`SFTP: Inbound: Received VERSION (v${i})`)}}e._version=i;e._extensions=n;if(n["limits@openssh.com"]==="1"){return requestLimits(e,((t,n)=>{if(!t){if(n.maxPktLen>0)e._maxOutPktLen=n.maxPktLen;if(n.maxReadLen>0)e._maxReadLen=n.maxReadLen;if(n.maxWriteLen>0)e._maxWriteLen=n.maxWriteLen;e.maxOpenHandles=n.maxOpenHandles>0?n.maxOpenHandles:Infinity}e.emit("ready")}))}e.emit("ready")},[B.STATUS]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readUInt32BE();const r=L.readString(true);const s=L.skipString();L.clear();if(s===undefined){if(n!==undefined)delete e._requests[n];return doFatalSFTPError(e,"Malformed STATUS packet")}if(e._debug){const t=JSON.stringify(r);e._debug(`SFTP: Inbound: Received STATUS (id:${n}, ${i}, ${t})`)}const o=e._requests[n];delete e._requests[n];if(o&&typeof o.cb==="function"){if(i===y.OK){o.cb();return}const e=new Error(r||w[i]||"Unknown status");e.code=i;o.cb(e)}},[B.HANDLE]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString();L.clear();if(i===undefined){if(n!==undefined)delete e._requests[n];return doFatalSFTPError(e,"Malformed HANDLE packet")}e._debug&&e._debug(`SFTP: Inbound: Received HANDLE (id:${n})`);const r=e._requests[n];delete e._requests[n];if(r&&typeof r.cb==="function")r.cb(undefined,i)},[B.DATA]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();let i;if(n!==undefined){i=e._requests[n];delete e._requests[n]}if(i&&typeof i.cb==="function"){if(i.buffer){const t=L.readString(i.buffer);L.clear();if(t!==undefined){e._debug&&e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${t})`);i.cb(undefined,i.buffer,t);return}}else{const t=L.readString();L.clear();if(t!==undefined){e._debug&&e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${t.length})`);i.cb(undefined,t);return}}}else{const t=L.skipString();L.clear();if(t!==undefined){e._debug&&e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${t})`);return}}return doFatalSFTPError(e,"Malformed DATA packet")},[B.NAME]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();let i;if(n!==undefined){i=e._requests[n];delete e._requests[n]}const r=L.readUInt32BE();if(r!==undefined){let t=[];for(let n=0;n<r;++n){const n=L.readString(true);const i=L.readString(true);const r=readAttrs(e._biOpt);if(r===undefined){t=undefined;break}t.push({filename:n,longname:i,attrs:r})}if(t!==undefined){e._debug&&e._debug(`SFTP: Inbound: Received NAME (id:${n}, ${t.length})`);L.clear();if(i&&typeof i.cb==="function")i.cb(undefined,t);return}}L.clear();return doFatalSFTPError(e,"Malformed NAME packet")},[B.ATTRS]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();let i;if(n!==undefined){i=e._requests[n];delete e._requests[n]}const r=readAttrs(e._biOpt);L.clear();if(r!==undefined){e._debug&&e._debug(`SFTP: Inbound: Received ATTRS (id:${n})`);if(i&&typeof i.cb==="function")i.cb(undefined,r);return}return doFatalSFTPError(e,"Malformed ATTRS packet")},[B.EXTENDED]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();if(n!==undefined){const t=e._requests[n];if(t){delete e._requests[n];switch(t.extended){case"statvfs@openssh.com":case"fstatvfs@openssh.com":{const i=e._biOpt;const r={f_bsize:L.readUInt64BE(i),f_frsize:L.readUInt64BE(i),f_blocks:L.readUInt64BE(i),f_bfree:L.readUInt64BE(i),f_bavail:L.readUInt64BE(i),f_files:L.readUInt64BE(i),f_ffree:L.readUInt64BE(i),f_favail:L.readUInt64BE(i),f_sid:L.readUInt64BE(i),f_flag:L.readUInt64BE(i),f_namemax:L.readUInt64BE(i)};if(r.f_namemax===undefined)break;if(e._debug){e._debug("SFTP: Inbound: Received EXTENDED_REPLY "+`(id:${n}, ${t.extended})`)}L.clear();if(typeof t.cb==="function")t.cb(undefined,r);return}case"limits@openssh.com":{const i={maxPktLen:L.readUInt64BE(),maxReadLen:L.readUInt64BE(),maxWriteLen:L.readUInt64BE(),maxOpenHandles:L.readUInt64BE()};if(i.maxOpenHandles===undefined)break;if(e._debug){e._debug("SFTP: Inbound: Received EXTENDED_REPLY "+`(id:${n}, ${t.extended})`)}L.clear();if(typeof t.cb==="function")t.cb(undefined,i);return}default:e._debug&&e._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ???)`);L.clear();if(typeof t.cb==="function")t.cb();return}}else{e._debug&&e._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ???)`);L.clear();return}}L.clear();return doFatalSFTPError(e,"Malformed EXTENDED_REPLY packet")}};const F={[C.INIT]:(e,t)=>{if(e._version!==-1)return doFatalSFTPError(e,"Duplicate INIT packet");const n={};L.init(t,1);let i=L.readUInt32BE();while(L.avail()){const e=L.readString(true);const t=L.readString(true);if(t===undefined){i=undefined;break}n[e]=t}L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed INIT packet");if(e._debug){const t=Object.keys(n);if(t.length){e._debug(`SFTP: Inbound: Received INIT (v${i}, exts:${t})`)}else{e._debug(`SFTP: Inbound: Received INIT (v${i})`)}}sendOrBuffer(e,P);e._version=i;e._extensions=n;e.emit("ready")},[C.OPEN]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);const r=L.readUInt32BE();const s=readAttrs(e._biOpt);L.clear();if(s===undefined)return doFatalSFTPError(e,"Malformed OPEN packet");e._debug&&e._debug(`SFTP: Inbound: Received OPEN (id:${n})`);if(!e.emit("OPEN",n,i,r,s)){e.status(n,y.OP_UNSUPPORTED)}},[C.CLOSE]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString();L.clear();if(i===undefined||i.length>256)return doFatalSFTPError(e,"Malformed CLOSE packet");e._debug&&e._debug(`SFTP: Inbound: Received CLOSE (id:${n})`);if(!e.emit("CLOSE",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.READ]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString();const r=L.readUInt64BE(e._biOpt);const s=L.readUInt32BE();L.clear();if(s===undefined||i.length>256)return doFatalSFTPError(e,"Malformed READ packet");e._debug&&e._debug(`SFTP: Inbound: Received READ (id:${n})`);if(!e.emit("READ",n,i,r,s)){e.status(n,y.OP_UNSUPPORTED)}},[C.WRITE]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString();const r=L.readUInt64BE(e._biOpt);const s=L.readString();L.clear();if(s===undefined||i.length>256)return doFatalSFTPError(e,"Malformed WRITE packet");e._debug&&e._debug(`SFTP: Inbound: Received WRITE (id:${n})`);if(!e.emit("WRITE",n,i,r,s)){e.status(n,y.OP_UNSUPPORTED)}},[C.LSTAT]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed LSTAT packet");e._debug&&e._debug(`SFTP: Inbound: Received LSTAT (id:${n})`);if(!e.emit("LSTAT",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.FSTAT]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString();L.clear();if(i===undefined||i.length>256)return doFatalSFTPError(e,"Malformed FSTAT packet");e._debug&&e._debug(`SFTP: Inbound: Received FSTAT (id:${n})`);if(!e.emit("FSTAT",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.SETSTAT]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);const r=readAttrs(e._biOpt);L.clear();if(r===undefined)return doFatalSFTPError(e,"Malformed SETSTAT packet");e._debug&&e._debug(`SFTP: Inbound: Received SETSTAT (id:${n})`);if(!e.emit("SETSTAT",n,i,r)){e.status(n,y.OP_UNSUPPORTED)}},[C.FSETSTAT]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString();const r=readAttrs(e._biOpt);L.clear();if(r===undefined||i.length>256)return doFatalSFTPError(e,"Malformed FSETSTAT packet");e._debug&&e._debug(`SFTP: Inbound: Received FSETSTAT (id:${n})`);if(!e.emit("FSETSTAT",n,i,r)){e.status(n,y.OP_UNSUPPORTED)}},[C.OPENDIR]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed OPENDIR packet");e._debug&&e._debug(`SFTP: Inbound: Received OPENDIR (id:${n})`);if(!e.emit("OPENDIR",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.READDIR]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString();L.clear();if(i===undefined||i.length>256)return doFatalSFTPError(e,"Malformed READDIR packet");e._debug&&e._debug(`SFTP: Inbound: Received READDIR (id:${n})`);if(!e.emit("READDIR",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.REMOVE]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed REMOVE packet");e._debug&&e._debug(`SFTP: Inbound: Received REMOVE (id:${n})`);if(!e.emit("REMOVE",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.MKDIR]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);const r=readAttrs(e._biOpt);L.clear();if(r===undefined)return doFatalSFTPError(e,"Malformed MKDIR packet");e._debug&&e._debug(`SFTP: Inbound: Received MKDIR (id:${n})`);if(!e.emit("MKDIR",n,i,r)){e.status(n,y.OP_UNSUPPORTED)}},[C.RMDIR]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed RMDIR packet");e._debug&&e._debug(`SFTP: Inbound: Received RMDIR (id:${n})`);if(!e.emit("RMDIR",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.REALPATH]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed REALPATH packet");e._debug&&e._debug(`SFTP: Inbound: Received REALPATH (id:${n})`);if(!e.emit("REALPATH",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.STAT]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed STAT packet");e._debug&&e._debug(`SFTP: Inbound: Received STAT (id:${n})`);if(!e.emit("STAT",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.RENAME]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);const r=L.readString(true);L.clear();if(r===undefined)return doFatalSFTPError(e,"Malformed RENAME packet");e._debug&&e._debug(`SFTP: Inbound: Received RENAME (id:${n})`);if(!e.emit("RENAME",n,i,r)){e.status(n,y.OP_UNSUPPORTED)}},[C.READLINK]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);L.clear();if(i===undefined)return doFatalSFTPError(e,"Malformed READLINK packet");e._debug&&e._debug(`SFTP: Inbound: Received READLINK (id:${n})`);if(!e.emit("READLINK",n,i)){e.status(n,y.OP_UNSUPPORTED)}},[C.SYMLINK]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);const r=L.readString(true);L.clear();if(r===undefined)return doFatalSFTPError(e,"Malformed SYMLINK packet");e._debug&&e._debug(`SFTP: Inbound: Received SYMLINK (id:${n})`);let s;if(e._isOpenSSH){s=e.emit("SYMLINK",n,r,i)}else{s=e.emit("SYMLINK",n,i,r)}if(!s){e.status(n,y.OP_UNSUPPORTED)}},[C.EXTENDED]:(e,t)=>{L.init(t,1);const n=L.readUInt32BE();const i=L.readString(true);if(i===undefined){L.clear();return doFatalSFTPError(e,"Malformed EXTENDED packet")}let r;if(L.avail())r=L.readRaw();L.clear();e._debug&&e._debug(`SFTP: Inbound: Received EXTENDED (id:${n})`);if(!e.emit("EXTENDED",n,i,r)){e.status(n,y.OP_UNSUPPORTED)}}};const{ERR_INVALID_ARG_TYPE:W,ERR_OUT_OF_RANGE:x,validateNumber:M}=n(379);const q=128;let G;const $=[];function allocNewPool(e){if($.length>0)G=$.pop();else G=Buffer.allocUnsafe(e);G.used=0}function checkPosition(e,t){if(!Number.isSafeInteger(e)){M(e,t);if(!Number.isInteger(e))throw new x(t,"an integer",e);throw new x(t,">= 0 and <= 2 ** 53 - 1",e)}if(e<0)throw new x(t,">= 0 and <= 2 ** 53 - 1",e)}function roundUpToMultipleOf8(e){return e+7&~7}function ReadStream(e,t,n){if(n===undefined)n={};else if(typeof n==="string")n={encoding:n};else if(n===null||typeof n!=="object")throw new TypeError('"options" argument must be a string or an object');else n=Object.create(n);if(n.highWaterMark===undefined)n.highWaterMark=64*1024;n.emitClose=false;n.autoDestroy=false;o.call(this,n);this.path=t;this.flags=n.flags===undefined?"r":n.flags;this.mode=n.mode===undefined?438:n.mode;this.start=n.start;this.end=n.end;this.autoClose=n.autoClose===undefined?true:n.autoClose;this.pos=0;this.bytesRead=0;this.closed=false;this.handle=n.handle===undefined?null:n.handle;this.sftp=e;this._opening=false;if(this.start!==undefined){checkPosition(this.start,"start");this.pos=this.start}if(this.end===undefined){this.end=Infinity}else if(this.end!==Infinity){checkPosition(this.end,"end");if(this.start!==undefined&&this.start>this.end){throw new x("start",`<= "end" (here: ${this.end})`,this.start)}}this.on("end",(function(){if(this.autoClose)this.destroy()}));if(!Buffer.isBuffer(this.handle))this.open()}h(ReadStream,o);ReadStream.prototype.open=function(){if(this._opening)return;this._opening=true;this.sftp.open(this.path,this.flags,this.mode,((e,t)=>{this._opening=false;if(e){this.emit("error",e);if(this.autoClose)this.destroy();return}this.handle=t;this.emit("open",t);this.emit("ready");this.read()}))};ReadStream.prototype._read=function(e){if(!Buffer.isBuffer(this.handle))return this.once("open",(()=>this._read(e)));if(this.destroyed)return;if(!G||G.length-G.used<q){allocNewPool(this.readableHighWaterMark||this._readableState.highWaterMark)}const t=G;let n=Math.min(G.length-G.used,e);const i=G.used;if(this.end!==undefined)n=Math.min(this.end-this.pos+1,n);if(n<=0)return this.push(null);this.sftp.read(this.handle,G,G.used,n,this.pos,((e,r)=>{if(e){this.emit("error",e);if(this.autoClose)this.destroy();return}let s=null;if(i+n===t.used&&t===G){t.used=roundUpToMultipleOf8(t.used+r-n)}else{const e=i+n&~7;const s=roundUpToMultipleOf8(i+r);if(e-s>=q)$.push(t.slice(s,e))}if(r>0){this.bytesRead+=r;s=t.slice(i,i+r)}this.pos+=r;this.push(s)}));G.used=roundUpToMultipleOf8(G.used+n)};ReadStream.prototype._destroy=function(e,t){if(this._opening&&!Buffer.isBuffer(this.handle)){this.once("open",closeStream.bind(null,this,t,e));return}closeStream(this,t,e);this.handle=null;this._opening=false};function closeStream(e,t,n){if(!e.handle)return onclose();e.sftp.close(e.handle,onclose);function onclose(i){i=i||n;t(i);e.closed=true;if(!i)e.emit("close")}}ReadStream.prototype.close=function(e){this.destroy(null,e)};Object.defineProperty(ReadStream.prototype,"pending",{get(){return this.handle===null},configurable:true});function WriteStream(e,t,n){if(n===undefined)n={};else if(typeof n==="string")n={encoding:n};else if(n===null||typeof n!=="object")throw new TypeError('"options" argument must be a string or an object');else n=Object.create(n);n.emitClose=false;n.autoDestroy=false;f.call(this,n);this.path=t;this.flags=n.flags===undefined?"w":n.flags;this.mode=n.mode===undefined?438:n.mode;this.start=n.start;this.autoClose=n.autoClose===undefined?true:n.autoClose;this.pos=0;this.bytesWritten=0;this.closed=false;this.handle=n.handle===undefined?null:n.handle;this.sftp=e;this._opening=false;if(this.start!==undefined){checkPosition(this.start,"start");this.pos=this.start}if(n.encoding)this.setDefaultEncoding(n.encoding);this.on("finish",(function(){if(this._writableState.finalCalled)return;if(this.autoClose)this.destroy()}));if(!Buffer.isBuffer(this.handle))this.open()}h(WriteStream,f);WriteStream.prototype._final=function(e){if(this.autoClose)this.destroy();e()};WriteStream.prototype.open=function(){if(this._opening)return;this._opening=true;this.sftp.open(this.path,this.flags,this.mode,((e,t)=>{this._opening=false;if(e){this.emit("error",e);if(this.autoClose)this.destroy();return}this.handle=t;const tryAgain=e=>{if(e){this.sftp.chmod(this.path,this.mode,(e=>tryAgain()));return}if(this.flags[0]==="a"){const tryStat=(e,n)=>{if(e){this.sftp.stat(this.path,((t,n)=>{if(t){this.destroy();this.emit("error",e);return}tryStat(null,n)}));return}this.pos=n.size;this.emit("open",t);this.emit("ready")};this.sftp.fstat(t,tryStat);return}this.emit("open",t);this.emit("ready")};this.sftp.fchmod(t,this.mode,tryAgain)}))};WriteStream.prototype._write=function(e,t,n){if(!Buffer.isBuffer(e)){const t=new W("data","Buffer",e);return this.emit("error",t)}if(!Buffer.isBuffer(this.handle)){return this.once("open",(function(){this._write(e,t,n)}))}this.sftp.write(this.handle,e,0,e.length,this.pos,((e,t)=>{if(e){if(this.autoClose)this.destroy();return n(e)}this.bytesWritten+=t;n()}));this.pos+=e.length};WriteStream.prototype._writev=function(e,t){if(!Buffer.isBuffer(this.handle)){return this.once("open",(function(){this._writev(e,t)}))}const n=this.sftp;const i=this.handle;let r=e.length;const onwrite=(e,n)=>{if(e){this.destroy();return t(e)}this.bytesWritten+=n;if(--r===0)t()};for(let t=0;t<e.length;++t){const r=e[t].chunk;n.write(i,r,0,r.length,this.pos,onwrite);this.pos+=r.length}};if(typeof f.prototype.destroy!=="function")WriteStream.prototype.destroy=ReadStream.prototype.destroy;WriteStream.prototype._destroy=ReadStream.prototype._destroy;WriteStream.prototype.close=function(e){if(e){if(this.closed){process.nextTick(e);return}this.on("close",e)}if(!this.autoClose)this.on("finish",this.destroy.bind(this));this.end()};WriteStream.prototype.destroySoon=WriteStream.prototype.end;Object.defineProperty(WriteStream.prototype,"pending",{get(){return this.handle===null},configurable:true});e.exports={flagsToString:v,OPEN_MODE:k,SFTP:SFTP,Stats:Stats,STATUS_CODE:y,stringToFlags:stringToFlags}},223:(e,t,n)=>{const{Ber:i}=n(461);let r;const s=Buffer[Symbol.species];const o=Object.getPrototypeOf(Uint8Array.prototype).fill;function readUInt32BE(e,t){return e[t++]*16777216+e[t++]*65536+e[t++]*256+e[t]}function bufferCopy(e,t,n,i,r){if(!r)r=0;if(i>e.length)i=e.length;let s=i-n;const o=t.length-r;if(s>o)s=o;t.set(new Uint8Array(e.buffer,e.byteOffset+n,s),r);return s}function bufferSlice(e,t,n){if(n===undefined)n=e.length;return new s(e.buffer,e.byteOffset+t,n-t)}function makeBufferParser(){let e=0;let t;const n={init:(n,i)=>{t=n;e=typeof i==="number"?i:0},pos:()=>e,length:()=>t?t.length:0,avail:()=>t&&e<t.length?t.length-e:0,clear:()=>{t=undefined},readUInt32BE:()=>{if(!t||e+3>=t.length)return;return t[e++]*16777216+t[e++]*65536+t[e++]*256+t[e++]},readUInt64BE:n=>{if(!t||e+7>=t.length)return;switch(n){case"always":return BigInt(`0x${t.hexSlice(e,e+=8)}`);case"maybe":if(t[e]>31)return BigInt(`0x${t.hexSlice(e,e+=8)}`);default:return t[e++]*72057594037927940+t[e++]*281474976710656+t[e++]*1099511627776+t[e++]*4294967296+t[e++]*16777216+t[e++]*65536+t[e++]*256+t[e++]}},skip:n=>{if(t&&n>0)e+=n},skipString:()=>{const i=n.readUInt32BE();if(i===undefined)return;e+=i;return e<=t.length?i:undefined},readByte:()=>{if(t&&e<t.length)return t[e++]},readBool:()=>{if(t&&e<t.length)return!!t[e++]},readList:()=>{const e=n.readString(true);if(e===undefined)return;return e?e.split(","):[]},readString:(i,r)=>{if(typeof i==="number"){r=i;i=undefined}const s=n.readUInt32BE();if(s===undefined)return;if(t.length-e<s||typeof r==="number"&&s>r){return}if(i){if(Buffer.isBuffer(i))return bufferCopy(t,i,e,e+=s);return t.utf8Slice(e,e+=s)}return bufferSlice(t,e,e+=s)},readRaw:n=>{if(!t)return;if(typeof n!=="number")return bufferSlice(t,e,e+=t.length-e);if(t.length-e>=n)return bufferSlice(t,e,e+=n)}};return n}function makeError(e,t,n){const i=new Error(e);if(typeof t==="boolean"){n=t;i.level="protocol"}else{i.level=t||"protocol"}i.fatal=!!n;return i}function writeUInt32BE(e,t,n){e[n++]=t>>>24;e[n++]=t>>>16;e[n++]=t>>>8;e[n++]=t;return n}const f=makeBufferParser();e.exports={bufferCopy:bufferCopy,bufferSlice:bufferSlice,FastBuffer:s,bufferFill:(e,t,n,i)=>o.call(e,t,n,i),makeError:makeError,doFatalError:(e,t,i,s)=>{let o;if(r===undefined)({DISCONNECT_REASON:r}=n(223));if(t instanceof Error){o=t;if(typeof i!=="number")s=r.PROTOCOL_ERROR;else s=i}else{o=makeError(t,i,true)}if(typeof s!=="number")s=r.PROTOCOL_ERROR;e.disconnect(s);e._destruct();e._onError(o);return Infinity},readUInt32BE:readUInt32BE,writeUInt32BE:writeUInt32BE,writeUInt32LE:(e,t,n)=>{e[n++]=t;e[n++]=t>>>8;e[n++]=t>>>16;e[n++]=t>>>24;return n},makeBufferParser:makeBufferParser,bufferParser:makeBufferParser(),readString:(e,t,n,i)=>{if(typeof n==="number"){i=n;n=undefined}if(t===undefined)t=0;const r=e.length-t;if(t<0||t>=e.length||r<4)return;const s=readUInt32BE(e,t);if(r<4+s||typeof i==="number"&&s>i)return;t+=4;const o=t+s;e._pos=o;if(n){if(Buffer.isBuffer(n))return bufferCopy(e,n,t,o);return e.utf8Slice(t,o)}return bufferSlice(e,t,o)},sigSSHToASN1:(e,t)=>{switch(t){case"ssh-dss":{if(e.length>40)return e;const t=new i.Writer;t.startSequence();let n=e.slice(0,20);let r=e.slice(20);if(n[0]&128){const e=Buffer.allocUnsafe(21);e[0]=0;n.copy(e,1);n=e}else if(n[0]===0&&!(n[1]&128)){n=n.slice(1)}if(r[0]&128){const e=Buffer.allocUnsafe(21);e[0]=0;r.copy(e,1);r=e}else if(r[0]===0&&!(r[1]&128)){r=r.slice(1)}t.writeBuffer(n,i.Integer);t.writeBuffer(r,i.Integer);t.endSequence();return t.buffer}case"ecdsa-sha2-nistp256":case"ecdsa-sha2-nistp384":case"ecdsa-sha2-nistp521":{f.init(e,0);const t=f.readString();const n=f.readString();f.clear();if(t===undefined||n===undefined)return;const r=new i.Writer;r.startSequence();r.writeBuffer(t,i.Integer);r.writeBuffer(n,i.Integer);r.endSequence();return r.buffer}default:return e}},convertSignature:(e,t)=>{switch(t){case"ssh-dss":{if(e.length<=40)return e;const t=new i.Reader(e);t.readSequence();let n=t.readString(i.Integer,true);let r=t.readString(i.Integer,true);let s=0;let o=0;if(n.length<20){const e=Buffer.allocUnsafe(20);e.set(n,1);n=e;n[0]=0}if(r.length<20){const e=Buffer.allocUnsafe(20);e.set(r,1);r=e;r[0]=0}if(n.length>20&&n[0]===0)s=1;if(r.length>20&&r[0]===0)o=1;const f=Buffer.allocUnsafe(n.length-s+(r.length-o));bufferCopy(n,f,s,n.length,0);bufferCopy(r,f,o,r.length,n.length-s);return f}case"ecdsa-sha2-nistp256":case"ecdsa-sha2-nistp384":case"ecdsa-sha2-nistp521":{if(e[0]===0)return e;const t=new i.Reader(e);t.readSequence();const n=t.readString(i.Integer,true);const r=t.readString(i.Integer,true);if(n===null||r===null)return;const s=Buffer.allocUnsafe(4+n.length+4+r.length);writeUInt32BE(s,n.length,0);s.set(n,4);writeUInt32BE(s,r.length,4+n.length);s.set(r,4+4+n.length);return s}}return e},sendPacket:(e,t,n)=>{if(!n&&e._kexinit!==undefined){if(e._queue===undefined)e._queue=[];e._queue.push(t);return false}e._cipher.encrypt(t);return true}}},983:(e,t,n)=>{const{kMaxLength:i}=n(300);const{createInflate:r,constants:{DEFLATE:s,INFLATE:o,Z_DEFAULT_CHUNK:f,Z_DEFAULT_COMPRESSION:h,Z_DEFAULT_MEMLEVEL:l,Z_DEFAULT_STRATEGY:u,Z_DEFAULT_WINDOWBITS:A,Z_PARTIAL_FLUSH:g}}=n(796);const _=r()._handle.constructor;function processCallback(){throw new Error("Should not get here")}function zlibOnError(e,t,n){const i=this._owner;const r=new Error(e);r.errno=t;r.code=n;i._err=r}function _close(e){if(!e._handle)return;e._handle.close();e._handle=null}class Zlib{constructor(e){const t=A;const n=h;const r=l;const s=u;const o=undefined;this._err=undefined;this._writeState=new Uint32Array(2);this._chunkSize=f;this._maxOutputLength=i;this._outBuffer=Buffer.allocUnsafe(this._chunkSize);this._outOffset=0;this._handle=new _(e);this._handle._owner=this;this._handle.onerror=zlibOnError;this._handle.init(t,n,r,s,this._writeState,processCallback,o)}writeSync(e,t){const n=this._handle;if(!n)throw new Error("Invalid Zlib instance");let i=e.length;let r=this._chunkSize-this._outOffset;let s=0;let o;let f;let h;let l=0;const u=this._writeState;let A=this._outBuffer;let _=this._outOffset;const p=this._chunkSize;while(true){n.writeSync(g,e,s,i,A,_,r);if(this._err)throw this._err;o=u[0];f=u[1];const t=i-f;const E=r-o;if(E>0){const e=_===0&&E===A.length?A:A.slice(_,_+E);_+=E;if(!h)h=e;else if(h.push===undefined)h=[h,e];else h.push(e);l+=e.byteLength;if(l>this._maxOutputLength){_close(this);throw new Error(`Output length exceeded maximum of ${this._maxOutputLength}`)}}else if(E!==0){throw new Error("have should not go down")}if(o===0||_>=p){r=p;_=0;A=Buffer.allocUnsafe(p)}if(o===0){s+=t;i=f}else{break}}this._outBuffer=A;this._outOffset=_;if(l===0)h=Buffer.alloc(0);if(t){h.totalLen=l;return h}if(h.push===undefined)return h;const E=Buffer.allocUnsafe(l);for(let e=0,t=0;e<h.length;++e){const n=h[e];E.set(n,t);t+=n.length}return E}}class ZlibPacketWriter{constructor(e){this.allocStart=0;this.allocStartKEX=0;this._protocol=e;this._zlib=new Zlib(s)}cleanup(){if(this._zlib)_close(this._zlib)}alloc(e,t){return Buffer.allocUnsafe(e)}finalize(e,t){if(this._protocol._kexinit===undefined||t){const t=this._zlib.writeSync(e,true);const n=this._protocol._cipher.allocPacket(t.totalLen);if(t.push===undefined){n.set(t,5)}else{for(let e=0,i=5;e<t.length;++e){const r=t[e];n.set(r,i);i+=r.length}}return n}return e}}class PacketWriter{constructor(e){this.allocStart=5;this.allocStartKEX=5;this._protocol=e}cleanup(){}alloc(e,t){if(this._protocol._kexinit===undefined||t)return this._protocol._cipher.allocPacket(e);return Buffer.allocUnsafe(e)}finalize(e,t){return e}}class ZlibPacketReader{constructor(){this._zlib=new Zlib(o)}cleanup(){if(this._zlib)_close(this._zlib)}read(e){return this._zlib.writeSync(e,false)}}class PacketReader{cleanup(){}read(e){return e}}e.exports={PacketReader:PacketReader,PacketWriter:PacketWriter,ZlibPacketReader:ZlibPacketReader,ZlibPacketWriter:ZlibPacketWriter}},283:(e,t,n)=>{const{SFTP:i}=n(58);const r=2**32-1;function onChannelOpenFailure(e,t,n,i){e._chanMgr.remove(t);if(typeof i!=="function")return;let r;if(n instanceof Error){r=n}else if(typeof n==="object"&&n!==null){r=new Error(`(SSH) Channel open failure: ${n.description}`);r.reason=n.reason}else{r=new Error("(SSH) Channel open failure: server closed channel unexpectedly");r.reason=""}i(r)}function onCHANNEL_CLOSE(e,t,n,r,s){if(typeof n==="function"){onChannelOpenFailure(e,t,r,n);return}if(typeof n!=="object"||n===null||n.incoming.state==="closed"){return}n.incoming.state="closed";if(n.readable)n.push(null);if(n.server){if(n.stderr.writable)n.stderr.end()}else if(n.stderr.readable){n.stderr.push(null)}if(n.constructor!==i&&(n.outgoing.state==="open"||n.outgoing.state==="eof")&&!s){n.close()}if(n.outgoing.state==="closing")n.outgoing.state="closed";e._chanMgr.remove(t);const o=n._readableState;const f=n._writableState;if(f&&!f.ending&&!f.finished&&!s)n.end();const h=n._callbacks;n._callbacks=[];for(let e=0;e<h.length;++e)h[e](true);if(n.server){if(!n.readable||n.destroyed||o&&o.endEmitted){n.emit("close")}else{n.once("end",(()=>n.emit("close")))}}else{let e;switch(n.type){case"direct-streamlocal@openssh.com":case"direct-tcpip":e=()=>n.emit("close");break;default:{const t=n._exit;e=()=>{if(t.code===null)n.emit("close",t.code,t.signal,t.dump,t.desc);else n.emit("close",t.code)}}}if(!n.readable||n.destroyed||o&&o.endEmitted){e()}else{n.once("end",e)}const t=n.stderr._readableState;if(!n.stderr.readable||n.stderr.destroyed||t&&t.endEmitted){n.stderr.emit("close")}else{n.stderr.once("end",(()=>n.stderr.emit("close")))}}}class ChannelManager{constructor(e){this._client=e;this._channels={};this._cur=-1;this._count=0}add(e){let t;if(this._cur<r){t=++this._cur}else if(this._count===0){this._cur=0;t=0}else{const e=this._channels;for(let n=0;n<r;++n){if(e[n]===undefined){t=n;break}}}if(t===undefined)return-1;this._channels[t]=e||true;++this._count;return t}update(e,t){if(typeof e!=="number"||e<0||e>=r||!isFinite(e))throw new Error(`Invalid channel id: ${e}`);if(t&&this._channels[e])this._channels[e]=t}get(e){if(typeof e!=="number"||e<0||e>=r||!isFinite(e))throw new Error(`Invalid channel id: ${e}`);return this._channels[e]}remove(e){if(typeof e!=="number"||e<0||e>=r||!isFinite(e))throw new Error(`Invalid channel id: ${e}`);if(this._channels[e]){delete this._channels[e];if(this._count)--this._count}}cleanup(e){const t=this._channels;this._channels={};this._cur=-1;this._count=0;const n=Object.keys(t);const i=this._client;for(let r=0;r<n.length;++r){const s=+n[r];const o=t[s];onCHANNEL_CLOSE(i,s,o._channel||o,e,true)}}}const s=(()=>{const e=Object.prototype.toString;return t=>e.call(t)==="[object RegExp]"})();function generateAlgorithmList(e,t,n){if(Array.isArray(e)&&e.length>0){for(let t=0;t<e.length;++t){if(n.indexOf(e[t])===-1)throw new Error(`Unsupported algorithm: ${e[t]}`)}return e}if(typeof e==="object"&&e!==null){const i=Object.keys(e);let r=t;for(let o=0;o<i.length;++o){const f=i[o];let h=e[f];switch(f){case"append":if(!Array.isArray(h))h=[h];if(Array.isArray(h)){for(let e=0;e<h.length;++e){const i=h[e];if(typeof i==="string"){if(!i||r.indexOf(i)!==-1)continue;if(n.indexOf(i)===-1)throw new Error(`Unsupported algorithm: ${i}`);if(r===t)r=r.slice();r.push(i)}else if(s(i)){for(let e=0;e<n.length;++e){const s=n[e];if(i.test(s)){if(r.indexOf(s)!==-1)continue;if(r===t)r=r.slice();r.push(s)}}}}}break;case"prepend":if(!Array.isArray(h))h=[h];if(Array.isArray(h)){for(let e=h.length;e>=0;--e){const i=h[e];if(typeof i==="string"){if(!i||r.indexOf(i)!==-1)continue;if(n.indexOf(i)===-1)throw new Error(`Unsupported algorithm: ${i}`);if(r===t)r=r.slice();r.unshift(i)}else if(s(i)){for(let e=n.length;e>=0;--e){const s=n[e];if(i.test(s)){if(r.indexOf(s)!==-1)continue;if(r===t)r=r.slice();r.unshift(s)}}}}}break;case"remove":if(!Array.isArray(h))h=[h];if(Array.isArray(h)){for(let e=0;e<h.length;++e){const n=h[e];if(typeof n==="string"){if(!n)continue;const e=r.indexOf(n);if(e===-1)continue;if(r===t)r=r.slice();r.splice(e,1)}else if(s(n)){for(let e=0;e<r.length;++e){if(n.test(r[e])){if(r===t)r=r.slice();r.splice(e,1);--e}}}}}break}}return r}return t}e.exports={ChannelManager:ChannelManager,generateAlgorithmList:generateAlgorithmList,onChannelOpenFailure:onChannelOpenFailure,onCHANNEL_CLOSE:onCHANNEL_CLOSE,isWritable:e=>e&&e.writable}},491:e=>{"use strict";e.exports=require("assert")},300:e=>{"use strict";e.exports=require("buffer")},113:e=>{"use strict";e.exports=require("crypto")},523:e=>{"use strict";e.exports=require("dns")},361:e=>{"use strict";e.exports=require("events")},147:e=>{"use strict";e.exports=require("fs")},685:e=>{"use strict";e.exports=require("http")},687:e=>{"use strict";e.exports=require("https")},808:e=>{"use strict";e.exports=require("net")},17:e=>{"use strict";e.exports=require("path")},781:e=>{"use strict";e.exports=require("stream")},404:e=>{"use strict";e.exports=require("tls")},837:e=>{"use strict";e.exports=require("util")},796:e=>{"use strict";e.exports=require("zlib")}};var t={};function __nccwpck_require__(n){var i=t[n];if(i!==undefined){return i.exports}var r=t[n]={exports:{}};var s=true;try{e[n](r,r.exports,__nccwpck_require__);s=false}finally{if(s)delete t[n]}return r.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var n=__nccwpck_require__(648);module.exports=n})();